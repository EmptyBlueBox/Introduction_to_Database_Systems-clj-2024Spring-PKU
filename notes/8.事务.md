#  第八章 事务



## 事务

核心：完整性

完整性的威胁: 网络故障、并发

一致性条件：两个贱户总和在转账前后保持不变

### 事务的定义

事务是由一系列操作序列构成的执行单元，这些操作要么都做，要么都不做，是一个不可分割的工作单位

#### 事务中的数据访问原语

<img src="./8.事务.assets/CleanShot 2024-05-11 at 14.43.04@2x.png" alt="CleanShot 2024-05-11 at 14.43.04@2x" style="zoom:50%;" />

#### 转账事务的原语表达

银行转帐：事务T以A帐户过户50¥到B帐户

read (A);
A : = A - 50;
write (A);
read(B);
B := B + 50;
write (B);

### SQL中事务的定义

事务以Begin transaction 开始，以Commit transaction或 Rollback transaction结束

Commit transaction表示提交，事务正常结束

Rollback transaction表示事务非正常结束，撤消事务已做的操作，回滚到事务开始时状态

#### 基于SQL编写转账事务

<img src="./8.事务.assets/CleanShot 2024-05-11 at 14.46.13@2x.png" alt="CleanShot 2024-05-11 at 14.46.13@2x" style="zoom:50%;" />

#### 事务中的错误检查

<img src="./8.事务.assets/CleanShot 2024-05-11 at 14.48.02@2x.png" alt="CleanShot 2024-05-11 at 14.48.02@2x" style="zoom:50%;" />

事务中的错误检查：MySQL

<img src="./8.事务.assets/CleanShot 2024-05-11 at 14.48.17@2x.png" alt="CleanShot 2024-05-11 at 14.48.17@2x" style="zoom:50%;" />

### 事务基本特性ACID

原子性（Atomicity）

一致性（Consistency）

隔离性（Isolation）两个事务并行结果等于串行结果

持久性（Durability）

### 事务生命周期图

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.32.49@2x.png" alt="CleanShot 2024-05-17 at 23.32.49@2x" style="zoom:50%;" />

## 事务调度

### 定义

事务的执行顺序称为一个调度，表示事务的指令在系统中执行的时间顺序

一组事务的调度必须保证: 包含了所有事务的操作指令、一个事务中指令的顺序必须保持不变

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.37.06@2x.png" alt="CleanShot 2024-05-17 at 23.37.06@2x" style="zoom:50%;" />

### 串行和并行

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.39.07@2x.png" alt="CleanShot 2024-05-17 at 23.39.07@2x" style="zoom:50%;" />

这么多: 不考

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.39.27@2x.png" alt="CleanShot 2024-05-17 at 23.39.27@2x" style="zoom:50%;" />

串行事务效率低，并行事务有可能破坏数据库的一致性

如何检验并行调度的正确性? 下节课讲

### 事务调度示例

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.41.12@2x.png" alt="CleanShot 2024-05-17 at 23.41.12@2x" style="zoom:50%;" />

#### 串行调度1

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.45.58@2x.png" alt="CleanShot 2024-05-17 at 23.45.58@2x" style="zoom:50%;" />

#### 串行调度2

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.46.14@2x.png" alt="CleanShot 2024-05-17 at 23.46.14@2x" style="zoom:50%;" />

#### 并行调度3

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.46.48@2x.png" alt="CleanShot 2024-05-17 at 23.46.48@2x" style="zoom:50%;" />

#### 并行调度4

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.49.11@2x.png" alt="CleanShot 2024-05-17 at 23.49.11@2x" style="zoom:50%;" />

### 可恢复调度

事务的恢复

- 一个事务失败了，应该能够撤消该事务对数据库的影响
- 如果有其它事务读取了失败事务写入的数据，则该事务应该撤消

可恢复调度: 对于每对事务T1与T2，如果T2读取了T1所写的数据，则T1必须先于T2提交

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.49.49@2x.png" alt="CleanShot 2024-05-17 at 23.49.49@2x" style="zoom:50%;" />

### 无级联调度

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.50.23@2x.png" alt="CleanShot 2024-05-17 at 23.50.23@2x" style="zoom:50%;" />

无级联调度: 对于每对事务T1与T2，如果T2读取了T1所写的数据，则T1必须在T2读取之前提交

无级联调度必是可恢复调度

**无级联调度就是多对可恢复调度**

## 并发调度中的不一致现象

### 丢失修改

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.53.10@2x.png" alt="CleanShot 2024-05-17 at 23.53.10@2x" style="zoom:50%;" />

写写不一致: 两个事务T1和T2读入同一数据并修改，T1提交的结果破坏了T2提交的结果，导致T2的修改丢失

### 读脏数据

**就是不可恢复调度**

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.54.44@2x.png" alt="CleanShot 2024-05-17 at 23.54.44@2x" style="zoom:50%;" />

写读不一致: 事务T1修改某一数据并将其写回磁盘，事务T2读取同一数据. 此后T1由于某种原因被撤消，其已修改过的数据恢复原值，造成T2读到的数据与数据库中数据不一致，则T2读到的就是脏数据

### 不能重复读

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.55.20@2x.png" alt="CleanShot 2024-05-17 at 23.55.20@2x" style="zoom:50%;" />

不能重复读: 事务T2读取某一数据后，事务TI对其做了修改，当T2再次读取该数据时，得到与前次不同的值

例子:

list：订票客户列表；airline（..count）：航班人数
r1(list) r2(list) w2(list) r2(count) w2(count) commit(t2) r1(count)

r1(list) 和 r1(count)  如果中间加入了旅客, 就会出现不能重复读的问题

### 发生幻象（Phantom）

<img src="./8.事务.assets/CleanShot 2024-05-17 at 23.56.39@2x.png" alt="CleanShot 2024-05-17 at 23.56.39@2x" style="zoom:50%;" />

插读不一致: 事务T2按一定条件读取某些数据后，事务T1插入一些满足这些条件的数据，当T2再次按相同条件读取数据时，发现多了一些记录

## 事务隔离性级别

### 定义

 SQL中事务隔离性级别的定义: 一般是 read commit

read uncommitted: 允许读取未提交的记录

read committed: 只允许读取已提交的记录，但不要求可重复读

repeatable read: 只允许读取已提交记录，并且一个事务对同一记录的两次读取之间，其它事务不能对该记录进行更新

serializable: 调度的执行必须等价于串行调度

###  隔高性级别的内部实现: read uncommitted

读脏数据

<img src="./8.事务.assets/CleanShot 2024-05-18 at 00.17.15@2x.png" alt="CleanShot 2024-05-18 at 00.17.15@2x" style="zoom:50%;" />

### 隔离性级别的内部实现： read committed

读完一次就释放读锁

<img src="./8.事务.assets/CleanShot 2024-05-18 at 00.18.14@2x.png" alt="CleanShot 2024-05-18 at 00.18.14@2x" style="zoom:50%;" />

读写读: 不可重复读:

<img src="./8.事务.assets/CleanShot 2024-05-18 at 00.19.01@2x.png" alt="CleanShot 2024-05-18 at 00.19.01@2x" style="zoom:50%;" />

### 隔离性级别的内部实现：repeatable read

直到所有读事务结束, 才释放读锁

<img src="./8.事务.assets/CleanShot 2024-05-18 at 00.19.41@2x.png" alt="CleanShot 2024-05-18 at 00.19.41@2x" style="zoom:50%;" />



### 隔离性级别与不一致现象的关系

![CleanShot 2024-05-18 at 00.28.03@2x](./8.事务.assets/CleanShot 2024-05-18 at 00.28.03@2x.png)

注意: read committed 也会导致丢失修改 (两个修改一个覆盖另一个)

Read commit: 读锁读完就结束

repeatable read: 读锁持续到事务结束 

例子:

![CleanShot 2024-05-18 at 00.33.08@2x](./8.事务.assets/CleanShot 2024-05-18 at 00.33.08@2x.png)

## 快照隔离

### 乐观并发控制

悲观并发控制的缺点是什么？

- 基本思想：通过加锁预防冲实（读-写、写一写）
- 基本机制：事务在进行读写操作之前先申请锁
- 不适合以读为主的冲突几率低的应用场合（读密集）
- 不必要的预防代价过高（读-读）

针对读密集应用，不加锁直接访问数据会怎样？

- 避免了加锁开销，直接执行读写操作效率高
- 通过回滚一方事务来解决事务间已经发生的冲突

### 快照隔离SI的基本恩想：多版本+回滚

**这一页很重要**

- 对数据库的写发生在提交时，形成数据项的一个提交版本（快照）
- 执行时间和访问数据项有交叠的写事务之间会产生冲突，先提交者赢
- 读操作访问该读事务开始那一刻的数据项最新版本，读写相互不会阻塞

<img src="./8.事务.assets/CleanShot 2024-05-18 at 00.49.47@2x.png" alt="CleanShot 2024-05-18 at 00.49.47@2x" style="zoom:50%;" />

问题出现在T3提交的时候, T3提交和T4提交产生 Y 的冲突, 因此按照T4来, T3 的修改全部被回滚, 最后的结果是 T4 的X=8, Y=9

### 快照隔离中的不一致现象

<img src="./8.事务.assets/CleanShot 2024-05-18 at 00.50.08@2x.png" alt="CleanShot 2024-05-18 at 00.50.08@2x" style="zoom:50%;" />

问题出在两个 commit 实际上是产生了不一致现象的, 两个事务按理来说会透支信用, 不能同时成功进行, 但是由于快照隔离不考虑两者之和大于0, 只要没用同时修改就行, 所以产生了透支信用 (和小于0) 的现象

思考：在悲观锁定下会发生这样的不一致吗？

从常用的 read committed 开始, 就不会产生了, 因为在 T1 commit 之前, T2 是不能读取 X 的, 所以 T2 不能判定是否 X+Y 大于 0

<img src="./8.事务.assets/CleanShot 2024-05-18 at 01.11.46@2x.png" alt="CleanShot 2024-05-18 at 01.11.46@2x" style="zoom:50%;" />

这个例子是说明了: 快照隔离的结果可能不是任意一种串行调度的结果

### 区分MySQL的当前读和快照读

<img src="./8.事务.assets/CleanShot 2024-05-18 at 01.13.13@2x.png" alt="CleanShot 2024-05-18 at 01.13.13@2x" style="zoom:50%;" />

只有这两种 select 和以下这三种操作是悲观锁, 其他操作都是快照读

如果设置 Serializable , 那么就走悲观封锁