# 第七章 关系规范化

## 关系模式设计问题



## 函数依赖



## 范式

范式是对关系的不同数据依赖程度的要求

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 04.42.06@2x.png" alt="CleanShot 2024-05-03 at 04.42.06@2x" style="zoom:50%;" />

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.42.35@2x.png" alt="CleanShot 2024-05-03 at 05.42.35@2x" style="zoom:50%;" />

### 1NF



### 2NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.45.10@2x.png" alt="CleanShot 2024-05-03 at 05.45.10@2x" style="zoom:50%;" />

AB->C

A->D



### 3NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.46.12@2x.png" alt="CleanShot 2024-05-03 at 05.46.12@2x" style="zoom:50%;" />

AB->C

C->D



一个全是主属性的关系模式一定是3NF的吗？一定是

### BCNF

所有的属性都是由码直接决定的

————————————————————————————————————————————

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.47.43@2x.png" alt="CleanShot 2024-05-03 at 05.47.43@2x" style="zoom:50%;" />

属于.

————————————————————————————————————————————

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.52.01@2x.png" alt="CleanShot 2024-05-03 at 05.52.01@2x" style="zoom:50%;" />

上面查询更快,但是不是BCNF,所以需要3NF. 并且可能有函数依赖被BCNF拆到两个表里面,丢失函数依赖 (参考以下例子).

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.54.04@2x.png" alt="CleanShot 2024-05-03 at 05.54.04@2x" style="zoom:50%;" />

————————————————————————————————————————————

全码属于BCNF吗？属于.

————————————————————————————————————————————

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.00.34@2x.png" alt="CleanShot 2024-05-03 at 06.00.34@2x" style="zoom:50%;" />

和BCNF就是区别在Y是不是主属性

## 多值依赖

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.12.16@2x.png" alt="CleanShot 2024-05-03 at 06.12.16@2x" style="zoom:50%;" />

————————————————————————————————————————————

![CleanShot 2024-05-03 at 06.05.24@2x](./7.关系规范化.assets/CleanShot 2024-05-03 at 06.05.24@2x.png)

————————————————————————————————————————————

多值依赖的子集不一定仍然还是

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.18.37@2x.png" alt="CleanShot 2024-05-03 at 06.18.37@2x" style="zoom:50%;" />

### 4NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.37.41@2x.png" alt="CleanShot 2024-05-03 at 06.37.41@2x" style="zoom:50%;" />



### 5NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.45.06@2x.png" alt="CleanShot 2024-05-03 at 06.45.06@2x" style="zoom:50%;" />

了解即可



### 思考题

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.45.38@2x.png" alt="CleanShot 2024-05-03 at 06.45.38@2x" style="zoom:50%;" />

留作作业题

————————————————————————————————————————————

一些证明题,比较难



## Armstrong 公理系统

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.03.11@2x.png" alt="CleanShot 2024-05-03 at 07.03.11@2x" style="zoom:50%;" />

Armstrong公理的应用示例

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.55.40@2x.png" alt="CleanShot 2024-05-03 at 06.55.40@2x" style="zoom:50%;" />



## 闭包计算

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.07.04@2x.png" alt="CleanShot 2024-05-03 at 07.07.04@2x" style="zoom:50%;" />

一般用这个定理来检查一个依赖是否正确

这个定理的证明不考察



## 候选码计算

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.16.43@2x.png" alt="CleanShot 2024-05-03 at 07.16.43@2x" style="zoom:50%;" />

所以所有候选码是 {AC, AD, AE}

判定范式:

2NF: 计算所有主属性元素的闭包,看是否包括B,发现都不包括,那么是2NF

3NF:对于非主属性是否存在传递依赖,AB->CD->B,不是3NF

注意传递依赖的定义!

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.20.38@2x.png" alt="CleanShot 2024-05-03 at 07.20.38@2x" style="zoom:50%;" />



## 函数依赖的等价和覆盖

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.30.03@2x.png" alt="CleanShot 2024-05-03 at 07.30.03@2x" style="zoom:50%;" />

————————————————————————————————————————————

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.30.47@2x.png" alt="CleanShot 2024-05-03 at 07.30.47@2x" style="zoom:50%;" />

等价.

