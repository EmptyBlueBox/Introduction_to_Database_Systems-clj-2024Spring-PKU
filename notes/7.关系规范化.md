# 第七章 关系规范化

## 关系模式设计问题



## 函数依赖

<img src="./7.关系规范化.assets/CleanShot 2024-05-23 at 15.38.52@2x.png" alt="CleanShot 2024-05-23 at 15.38.52@2x" style="zoom:50%;" />

<img src="./7.关系规范化.assets/CleanShot 2024-05-23 at 15.39.00@2x.png" alt="CleanShot 2024-05-23 at 15.39.00@2x" style="zoom:50%;" />

不同的码:

<img src="./7.关系规范化.assets/CleanShot 2024-05-23 at 15.38.31@2x.png" alt="CleanShot 2024-05-23 at 15.38.31@2x" style="zoom:50%;" />

## 范式

范式是对关系的不同数据依赖程度的要求

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 04.42.06@2x.png" alt="CleanShot 2024-05-03 at 04.42.06@2x" style="zoom:50%;" />

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.42.35@2x.png" alt="CleanShot 2024-05-03 at 05.42.35@2x" style="zoom:50%;" />

### 1NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-23 at 15.39.25@2x.png" alt="CleanShot 2024-05-23 at 15.39.25@2x" style="zoom:50%;" />

### 2NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-09 at 19.58.56@2x.png" alt="CleanShot 2024-05-09 at 19.58.56@2x" style="zoom:50%;" />

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.45.10@2x.png" alt="CleanShot 2024-05-03 at 05.45.10@2x" style="zoom:50%;" />

AB->C

A->D

D被部分码决定



### 3NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-09 at 19.59.09@2x.png" alt="CleanShot 2024-05-09 at 19.59.09@2x" style="zoom:50%;" />

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.46.12@2x.png" alt="CleanShot 2024-05-03 at 05.46.12@2x" style="zoom:50%;" />

AB->C

C->D

C, D都被全码决定, 但是D同时还间接被决定



一个全是主属性的关系模式一定是3NF的吗？一定是

### BCNF

所有的属性都是由码直接决定的

————————————————————————————————————————————

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.47.43@2x.png" alt="CleanShot 2024-05-03 at 05.47.43@2x" style="zoom:50%;" />

属于.

————————————————————————————————————————————

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.52.01@2x.png" alt="CleanShot 2024-05-03 at 05.52.01@2x" style="zoom:50%;" />

上面查询更快,但是不是BCNF,所以需要3NF. 并且可能有函数依赖被BCNF拆到两个表里面,丢失函数依赖 (参考以下例子).

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.54.04@2x.png" alt="CleanShot 2024-05-03 at 05.54.04@2x" style="zoom:50%;" />

————————————————————————————————————————————

全码属于BCNF吗？属于.

————————————————————————————————————————————

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.00.34@2x.png" alt="CleanShot 2024-05-03 at 06.00.34@2x" style="zoom:50%;" />

和BCNF就是区别在Y是不是主属性

## 多值依赖

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.12.16@2x.png" alt="CleanShot 2024-05-03 at 06.12.16@2x" style="zoom:50%;" />

————————————————————————————————————————————

![CleanShot 2024-05-03 at 06.05.24@2x](./7.关系规范化.assets/CleanShot 2024-05-03 at 06.05.24@2x.png)

————————————————————————————————————————————

多值依赖的子集不一定仍然还是

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.18.37@2x.png" alt="CleanShot 2024-05-03 at 06.18.37@2x" style="zoom:50%;" />

### 4NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.37.41@2x.png" alt="CleanShot 2024-05-03 at 06.37.41@2x" style="zoom:50%;" />



### 5NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.45.06@2x.png" alt="CleanShot 2024-05-03 at 06.45.06@2x" style="zoom:50%;" />

了解即可



### 思考题

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.45.38@2x.png" alt="CleanShot 2024-05-03 at 06.45.38@2x" style="zoom:50%;" />

留作作业题

————————————————————————————————————————————

一些证明题,比较难



## Armstrong 公理系统

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.03.11@2x.png" alt="CleanShot 2024-05-03 at 07.03.11@2x" style="zoom:50%;" />

Armstrong公理的应用示例

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.55.40@2x.png" alt="CleanShot 2024-05-03 at 06.55.40@2x" style="zoom:50%;" />



## 闭包计算

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.07.04@2x.png" alt="CleanShot 2024-05-03 at 07.07.04@2x" style="zoom:50%;" />

一般用这个定理来检查一个依赖是否正确

这个定理的证明不考察



## 候选码计算

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.16.43@2x.png" alt="CleanShot 2024-05-03 at 07.16.43@2x" style="zoom:50%;" />

所以所有候选码是 {AC, AD, AE}

判定范式:

2NF: 计算所有主属性元素的闭包,看是否包括B,发现都不包括,那么是2NF

3NF:对于非主属性是否存在传递依赖,AB->CD->B,不是3NF

注意传递依赖的定义!

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.20.38@2x.png" alt="CleanShot 2024-05-03 at 07.20.38@2x" style="zoom:50%;" />



## 函数依赖的等价和覆盖

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.30.03@2x.png" alt="CleanShot 2024-05-03 at 07.30.03@2x" style="zoom:50%;" />

————————————————————————————————————————————

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.30.47@2x.png" alt="CleanShot 2024-05-03 at 07.30.47@2x" style="zoom:50%;" />

等价.

### 函数依赖集F的最小覆盖

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.23.59@2x.png" alt="CleanShot 2024-05-11 at 14.23.59@2x" style="zoom:50%;" />

无冗余化是跟测试顺序有关系的, 测试顺序不同, 删除的冗余关系也不同

要遵守先既约化(变量无冗余), 最后再无冗余化

如果两个反了, 可能有冗余的函数依赖



#### 多值传递律

不是理想的多值传递律, 举一个反例:
$$
X\rightarrow\rightarrow Y, Y\rightarrow\rightarrow Z
\Rightarrow X\rightarrow\rightarrow Z-Y
$$
根据已有的知识:
$$
X\rightarrow\rightarrow YZ
$$
那么不一定有
$$
X\rightarrow\rightarrow Y
$$
具体例子:

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.14.06@2x.png" alt="CleanShot 2024-05-11 at 13.14.06@2x" style="zoom:50%;" />

从而举出反例:
$$
A\rightarrow\rightarrow BC, BC\rightarrow\rightarrow C\Rightarrow A\rightarrow\rightarrow C
$$
这个推出和上述的结论矛盾 ($BC\rightarrow\rightarrow C$ 是因为: 函数依赖是多值依赖的特例)

#### 联合律

略过  

## 模式分解

### 函数依赖在属性集上的投影

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.32.01@2x.png" alt="CleanShot 2024-05-11 at 13.32.01@2x" style="zoom:50%;" />

不需要考虑了. 因为A已经决定了BCD, 所以组合属性 AB、AC、AD都没有必要考虑了, 同理其实CD也没有必要考虑

### 模式分解定义

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.34.47@2x.png" alt="CleanShot 2024-05-11 at 13.34.47@2x" style="zoom:50%;" />

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.39.04@2x.png" alt="CleanShot 2024-05-11 at 13.39.04@2x" style="zoom:50%;" />

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.39.26@2x.png" alt="CleanShot 2024-05-11 at 13.39.26@2x" style="zoom:50%;" />

## 保持函数依赖的分解

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.40.17@2x.png" alt="CleanShot 2024-05-11 at 13.40.17@2x" style="zoom:50%;" />

### 如何判断分解是保持函数依赖的

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.44.23@2x.png" alt="CleanShot 2024-05-11 at 13.44.23@2x" style="zoom:50%;" />

### 丢失函数依赖的分解实例

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.44.41@2x.png" alt="CleanShot 2024-05-11 at 13.44.41@2x" style="zoom:50%;" />



## 无损连接分解

### 有损分解的例子

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.45.02@2x.png" alt="CleanShot 2024-05-11 at 13.45.02@2x" style="zoom:50%;" />

### 无损连接分解的定义

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.45.24@2x.png" alt="CleanShot 2024-05-11 at 13.45.24@2x" style="zoom:50%;" />

### 无损连接分解的判别算法

无损连接分解的判别算法考试不要求

### 分解为两个关系模式的无损分解

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.46.08@2x.png" alt="CleanShot 2024-05-11 at 13.46.08@2x" style="zoom:50%;" />

判定算法:

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.46.21@2x.png" alt="CleanShot 2024-05-11 at 13.46.21@2x" style="zoom:50%;" />

 但是其实正向不成立,只能推出多值依赖

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.55.06@2x.png" alt="CleanShot 2024-05-11 at 13.55.06@2x" style="zoom:50%;" />

### 分解为两个关系模式的无损分解示例

 <img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.55.56@2x.png" alt="CleanShot 2024-05-11 at 13.55.56@2x" style="zoom:50%;" />

## 关系模式分解算法

### 保持无损: 分解之后BCNF

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.56.38@2x.png" alt="CleanShot 2024-05-11 at 13.56.38@2x" style="zoom:50%;" />

是不是无损的? 是的  

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.04.39@2x.png" alt="CleanShot 2024-05-11 at 14.04.39@2x" style="zoom:50%;" />

#### 例子

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.02.53@2x.png" alt="CleanShot 2024-05-11 at 14.02.53@2x" style="zoom:50%;" />

#### 练习：如何构造一个有N种BCNF分解结果的关系模式

1. <img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.05.48@2x.png" alt="CleanShot 2024-05-11 at 14.05.48@2x" style="zoom:50%;" />
2. <img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.06.03@2x.png" alt="CleanShot 2024-05-11 at 14.06.03@2x" style="zoom:50%;" />

第二种不知道多少, 没讲

### 达到4NF无损连接分解算法

不讲

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.06.51@2x.png" alt="CleanShot 2024-05-11 at 14.06.51@2x" style="zoom:50%;" />

#### 例子

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.08.04@2x.png" alt="CleanShot 2024-05-11 at 14.08.04@2x" style="zoom:50%;" />

### 关于BCNF分解的额外讨论

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.13.20@2x.png" alt="CleanShot 2024-05-11 at 14.13.20@2x" style="zoom:50%;" />

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.13.28@2x.png" alt="CleanShot 2024-05-11 at 14.13.28@2x" style="zoom:50%;" />

左边分解太碎了

### 保持函数依赖的分解: 最高3NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.16.08@2x.png" alt="CleanShot 2024-05-11 at 14.16.08@2x" style="zoom:50%;" />

为什么第三点的时候算法终止? 因为此时已经是3NF了

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.29.20@2x.png" alt="CleanShot 2024-05-11 at 14.29.20@2x" style="zoom:50%;" />

如果XA=U, 此时B不可能是违反3NF的例子

#### 丢失函数依赖的BCNF分解

跳过了

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.15.09@2x.png" alt="CleanShot 2024-05-11 at 14.15.09@2x" style="zoom:50%;" />

#### 达到3NF保持函数依赖的分解

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.31.36@2x.png" alt="CleanShot 2024-05-11 at 14.31.36@2x" style="zoom:50%;" />

### 同时保持函数依赖和无损连接的分解

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.33.56@2x.png" alt="CleanShot 2024-05-11 at 14.33.56@2x" style="zoom:50%;" />

不能在保持无损的结果上改进, 很难, 应该在保持函数依赖的结果上改进

#### 同时保持函数依赖和无损连接的分解算法

再加一个表, 代表了原来的码, 可以限定不会出现新的行, 比如给上面的例子加一个表AB

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.35.41@2x.png" alt="CleanShot 2024-05-11 at 14.35.41@2x" style="zoom:50%;" />

## 模式调优

跳过
