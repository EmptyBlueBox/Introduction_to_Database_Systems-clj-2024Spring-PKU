# 第七章 关系规范化

## 关系模式设计问题

### 异常

信息的不可表示问题

* 插入异常：如果没有职工具有8级工资，则8级工资的工资数额就难以插入
* 删除异常：如果仅有职工赵明具有4级工资，删除赵明则会将有关4级工资的工资数额信息也一并删除

信息的冗余问题

* 数据冗余：职工很多，工资级别有限，每一级别的工资数额反复存储多次
* 更新异常：如果将5级工资的工资数额调为620，则需要找到每个具有5级工资的职工，逐一修改

### 不良的数据依赖

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 03.10.59@2x.png" alt="CleanShot 2024-06-14 at 03.10.59@2x" style="zoom:50%;" />

解决之道：分解！分解！！再分解！！！

### 主码与空值

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 03.11.17@2x.png" alt="CleanShot 2024-06-14 at 03.11.17@2x" style="zoom:50%;" />

## 函数依赖

### 函数依赖

设$R(U)$是属性集$U$上的关系模式，$X,Y\subseteq U$, $r$是$R(U)$上的任意一个关系，如果成立

**对 $\forall t,s\in r$ , 若$t[X]=s[X]$, 则$t[Y]=s[Y]$** 

则称“X函数决定Y” 或 “Y函数依赖于X”, 记作 X $\rightarrow$​ Y。 称X为决定因素

$如sno\to sname,(sno,cno)\to grade$

函数依赖的双重否定形式的定义: $不存在t,s\in r,t[X]=s[X],但t[Y]\neq s[Y]$​

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 02.52.00@2x.png" alt="CleanShot 2024-06-14 at 02.52.00@2x" style="zoom:50%;" />

检验: A→C? C→A? AB→D?

满足依赖的关系：依赖在模式的某个关系实例上成立 

模式上成立的依赖：依赖在模式的所有关系实例上都成立

#### 例子

找出所有可能的函数依赖

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 02.52.52@2x.png" alt="CleanShot 2024-06-14 at 02.52.52@2x" style="zoom:50%;" />

A→B, B → C

A→A, B → B, C → C, A → C

AB→А, AB → В, АВ → С, АВС→А, АВС→В...

### 平凡函数依赖

如果$X\to Y,Y\subseteq X$​,则称其为平凡的函数依赖, 否则称为非平凡的函数依赖

如（sno, sname）$\rightarrow$​ sname 是平凡的函数依赖

Question: 一个关系模式有n个属性，在它上面成立的所有可能的函数依赖有多少个？非平凡的函数依赖有多少个？

Answer: $(2^n-1)^2$, $(2^n-1)^2 - 2^n$

Question: 如果R（U）的候选码是整个属性集U，这称为**全码**, 问：一个全码的关系模式存在非平凡的函数依赖吗？

Answer: 不存在, 因为如果存在一个属性可以被另一个属性决定, 那么它可以被剔除出候选码, 那也就和题设矛盾了.

### 部分函数依赖

如果 $X\to Y$ ，且对于任意 X 的真子集 $X^{'}$，都有 $X^{\prime}\nrightarrow Y$ , 则称 Y 对 X 完全函数依赖，记作 $X\overset{f}{\operatorname*{\operatorname*{\to}}}Y$​

否则称 Y 对 X 部分函数依赖，记作 $X\overset{p}{\operatorname*{\operatorname*{\to}}}Y$

$(sno,cno)\overset{f}{\operatorname*{\to}}grade\quad(sno,cno)\overset{p}{\operatorname*{\to}}sname$

### 传递函数依赖

在 R(U) 中,如果: $X\to Y,Y\to Z,Y\nrightarrow X,\text{且 }Z\nsubseteq Y$ , 则称 Z 对 X 传递函数依赖

sno → dno, dno → dean

Question: 定义中为什么要求 $Z\nsubseteq Y$ , $Y\nrightarrow X$ ？

Answer: 避免了冗余依赖和循环依赖

1. **$Z \nsubseteq Y$**：
   这一条件确保 $Z$ 不是 $Y$ 的子集。如果 $Z \subseteq Y$，那么 $Z$ 的信息已经完全包含在 $Y$ 中，$Y \to Z$ 就没有实际意义，因为 $Z$ 已经是 $Y$ 的一部分。这会导致 $Z$ 对 $X$​ 的依赖不再是传递性的，而是直接的。
2. **$Y \nrightarrow X$**：
   这一条件确保了 $Y$ 不是 $X$ 的超键。换句话说，$Y$ 不能完全决定 $X$，否则 $X \to Y$ 和 $Y \to X$ 就意味着 $X$ 和 $Y$ 是相互决定的，这会破坏传递依赖的顺序性。

Question: 如何把部分函数依赖整理成传递函数依赖的形式？

Answer: 如下, 找到部分函数依赖的真子集

部分函数依赖$:X\to Y,X^\prime\subset X,X^{\prime}\to Y$ $\Rightarrow$ 传递函数依赖$:X\to X^\prime,X^{\prime}\to Y(X^{\prime}\nrightarrow X)$

### 为何要定义部分函数依赖和传递函数依赖

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 03.01.34@2x.png" alt="CleanShot 2024-06-14 at 03.01.34@2x" style="zoom:50%;" />

主要问题：如果关系模式设计不当，把本来彼此没有依赖关系的两个属性放在同一个关系模式中，所造成的对候选码的部分依赖和传递依赖是在现实中不存在的，从而会出现异常

### 两个问题

现实中的函数依赖：

$$F_1=\{(\text{学号,课程号})\to\text{成绩}\}$$
$$F_2=\{\text{学号}\to\text{姓名}\}$$​

问题一：理想的关系模式设计是怎样的？左边的姓名属性应该分配到哪个关系模式中？

不知道.

问题二：存在对候选码的部分函数依赖则一定存在对候选码的传递函数依赖，换言之部分依赖可以整理成传递依赖的形式，对否？

部分函数依赖$:X\to Y,X^\prime\subset X,X^{\prime}\to Y$ $\Rightarrow$ 传递函数依赖$:X\to X^\prime,X^{\prime}\to Y(X^{\prime}\nrightarrow X)$​

但是不一定, 不一定可以保证 $Z\nsubseteq Y$ 和 $X^\prime\nrightarrow X$

### 不同的码

#### 超码

设$K$为$R(U,F)$的属性或属性组，若$K\to U$,则称$K$为$R$的超码

#### 候选码

设$K$为$R(U,F)$的超码，若$K\overset{f}{\operatorname*{\to}}U$,则称$K$为$R$的候选码

#### 主属性

包含在任意候选码中的属性，称作主属性

$(F=\{AB\to C,C\to AB\}$,候选码有两个：$AB$和$C$,均为主属性)

#### 全码

关系模式$R(U,F)$的码由整个属性集$U$构成

(一般由不带属性的多对多联系映射过来的关系模式是全码，如SPJ)

## 范式

### 范式

定义: 通过模式分解将一个低级范式转换 若干个高级范式的过程称作规范化（概念的纯粹化）

范式是对关系的不同数据依赖程度的要求

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 03.56.32@2x.png" alt="CleanShot 2024-06-14 at 03.56.32@2x" style="zoom:50%;" />

升级过程

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 04.42.06@2x.png" alt="CleanShot 2024-05-03 at 04.42.06@2x" style="zoom:30%;" />

### 1NF

关系中每一分量不可再分, 也即不能以集合、序列等作为属性值

就是普通的表, 单元格都是一个个的数, 不是集合

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 04.03.45@2x.png" alt="CleanShot 2024-06-14 at 04.03.45@2x" style="zoom:50%;" />

#### 1NF与查询效率的折中

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 03.57.39@2x.png" alt="CleanShot 2024-06-14 at 03.57.39@2x" style="zoom:50%;" />

两个都保存，数据冗余，更新困难

只保存一个，某些查询困难

#### 1NF与应用对属性粒度的处理需求

分量是否需要再分，与具体应用有关

如果用到值的一部分，则需要进一步分割

否则需要应用编码解析

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 03.58.07@2x.png" alt="CleanShot 2024-06-14 at 03.58.07@2x" style="zoom:50%;" />

#### 1NF与数据质量的控制准则

较细的原子粒度有助于标准化，施加约束避免输入错误，从而提高数据质量

北京大学，北京，中国，100871，11/25/2006

中国，北京，北京大学，100871，25/11/2006

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 03.58.39@2x.png" alt="CleanShot 2024-06-14 at 03.58.39@2x" style="zoom:50%;" />

#### 1NF关系模式的不良特性

- 插入异常：如果学生没有选课，关于他的个人信息及所在系的信息就无法插入
- 删除异常：如果删除学生的选课信息，则他的个人信息及所在系的信息也随之删除
- 更新异常：如果学生转系，若他选修了K门课，则需要修改K次
- 数据冗余：如果一个学生选修了K门课，则有关他的所在系的信息重复k次

### 2NF

#### 定义

2NF消除非主属性对码的部分依赖

若$R\in1NF$,且每个非主属性完全依赖于码, 则称$R\in2NF$​

#### 如何将关系模式改进到2NF

非主属性有两种，一种完全依赖于码，一种部分依赖于码，据此将属性集划分为两部分

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 04.00.54@2x.png" alt="CleanShot 2024-06-14 at 04.00.54@2x" style="zoom:50%;" />

快速热身：关系模式 R(A,B,C,D), 给出它的一个函数依赖集，使得码为 AB，并且 R 属于 1NF 而不属于 2NF

AB $\rightarrow$ C

A $\rightarrow$ D

D被部分码决定

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 04.01.03@2x.png" alt="CleanShot 2024-06-14 at 04.01.03@2x" style="zoom:50%;" />

#### 2NF关系模式的不良特性

S_D (sno, sname, dno, dean)

- 插入异常：如果系中没有学生，则有关系的信息就无法插入
- 删除异常：如果删除某系中全部学生，则该系的系主任信息也随之删除
- 更新异常：如果学生转系，不但要修改dno，还要修改dean
- 数据冗余：每个学生都存储了其系主任的信息

### 3NF

#### 定义

3NF 的目标是消除非主属性对码的传递依赖

关系模式$R(U,F)$中，若不存在这样的码$X$, 属性组$Y$及非主属性$Z(Z\nsubseteq Y)$, 使得下式成立：$$X\to Y,Y\to Z,Y\to X$$ 则称$R\in3NF$​

#### 如何将关系模式改进到3NF

砸断函数依赖的传递链

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 04.09.01@2x.png" alt="CleanShot 2024-06-14 at 04.09.01@2x" style="zoom:50%;" />

快速热身：关系模式R（A,B,C,D），给出它的一个函数依赖集，使得码为AB，并且R属于2NF而不属于3NF

AB $\rightarrow$ C

C $\rightarrow$ D

C, D 都不会被全码的真子集决定, 但是D间接被C决定

#### 问题

<img src="./7.关系规范化.assets/CleanShot 2024-06-14 at 04.09.36@2x.png" alt="CleanShot 2024-06-14 at 04.09.36@2x" style="zoom:50%;" />

一个全是主属性的关系模式一定是3NF的吗？

一定是

### BCNF

所有的属性都是由码直接决定的

#### 问题

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.47.43@2x.png" alt="CleanShot 2024-05-03 at 05.47.43@2x" style="zoom:50%;" />

属于.

#### 比较下面两个模式各自的优缺点?

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.52.01@2x.png" alt="CleanShot 2024-05-03 at 05.52.01@2x" style="zoom:50%;" />

上面查询更快,但是不是BCNF,所以需要3NF. 并且可能有函数依赖被BCNF拆到两个表里面,丢失函数依赖 (参考以下例子).

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 05.54.04@2x.png" alt="CleanShot 2024-05-03 at 05.54.04@2x" style="zoom:50%;" />

全码属于BCNF吗？属于.

### 3NF的另外一种定义

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.00.34@2x.png" alt="CleanShot 2024-05-03 at 06.00.34@2x" style="zoom:50%;" />

和BCNF就是区别在Y是不是主属性

## 多值依赖

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.12.16@2x.png" alt="CleanShot 2024-05-03 at 06.12.16@2x" style="zoom:50%;" />

例子:

![CleanShot 2024-05-03 at 06.05.24@2x](./7.关系规范化.assets/CleanShot 2024-05-03 at 06.05.24@2x.png)

多值依赖的子集不一定仍然还是:

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.18.37@2x.png" alt="CleanShot 2024-05-03 at 06.18.37@2x" style="zoom:50%;" />

### 4NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.37.41@2x.png" alt="CleanShot 2024-05-03 at 06.37.41@2x" style="zoom:50%;" />



### 5NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.45.06@2x.png" alt="CleanShot 2024-05-03 at 06.45.06@2x" style="zoom:50%;" />

了解即可



### 思考题

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.45.38@2x.png" alt="CleanShot 2024-05-03 at 06.45.38@2x" style="zoom:50%;" />

留作作业题

————————————————————————————————————————————

一些证明题,比较难



## Armstrong 公理系统

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.03.11@2x.png" alt="CleanShot 2024-05-03 at 07.03.11@2x" style="zoom:50%;" />

Armstrong公理的应用示例

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 06.55.40@2x.png" alt="CleanShot 2024-05-03 at 06.55.40@2x" style="zoom:50%;" />



## 闭包计算

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.07.04@2x.png" alt="CleanShot 2024-05-03 at 07.07.04@2x" style="zoom:50%;" />

一般用这个定理来检查一个依赖是否正确

这个定理的证明不考察



## 候选码计算

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.16.43@2x.png" alt="CleanShot 2024-05-03 at 07.16.43@2x" style="zoom:50%;" />

所以所有候选码是 {AC, AD, AE}

判定范式:

2NF: 计算所有主属性元素的闭包,看是否包括B,发现都不包括,那么是2NF

3NF:对于非主属性是否存在传递依赖,AB->CD->B,不是3NF

注意传递依赖的定义!

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.20.38@2x.png" alt="CleanShot 2024-05-03 at 07.20.38@2x" style="zoom:50%;" />



## 函数依赖的等价和覆盖

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.30.03@2x.png" alt="CleanShot 2024-05-03 at 07.30.03@2x" style="zoom:50%;" />

————————————————————————————————————————————

<img src="./7.关系规范化.assets/CleanShot 2024-05-03 at 07.30.47@2x.png" alt="CleanShot 2024-05-03 at 07.30.47@2x" style="zoom:50%;" />

等价.

### 函数依赖集F的最小覆盖

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.23.59@2x.png" alt="CleanShot 2024-05-11 at 14.23.59@2x" style="zoom:50%;" />

无冗余化是跟测试顺序有关系的, 测试顺序不同, 删除的冗余关系也不同

要遵守先既约化(变量无冗余), 最后再无冗余化

如果两个反了, 可能有冗余的函数依赖



#### 多值传递律

不是理想的多值传递律, 举一个反例:
$$
X\rightarrow\rightarrow Y, Y\rightarrow\rightarrow Z
\Rightarrow X\rightarrow\rightarrow Z-Y
$$
根据已有的知识:
$$
X\rightarrow\rightarrow YZ
$$
那么不一定有
$$
X\rightarrow\rightarrow Y
$$
具体例子:

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.14.06@2x.png" alt="CleanShot 2024-05-11 at 13.14.06@2x" style="zoom:50%;" />

从而举出反例:
$$
A\rightarrow\rightarrow BC, BC\rightarrow\rightarrow C\Rightarrow A\rightarrow\rightarrow C
$$
这个推出和上述的结论矛盾 ($BC\rightarrow\rightarrow C$ 是因为: 函数依赖是多值依赖的特例)

#### 联合律

略过  

## 模式分解

### 函数依赖在属性集上的投影

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.32.01@2x.png" alt="CleanShot 2024-05-11 at 13.32.01@2x" style="zoom:50%;" />

不需要考虑了. 因为A已经决定了BCD, 所以组合属性 AB、AC、AD都没有必要考虑了, 同理其实CD也没有必要考虑

### 模式分解定义

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.34.47@2x.png" alt="CleanShot 2024-05-11 at 13.34.47@2x" style="zoom:50%;" />

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.39.04@2x.png" alt="CleanShot 2024-05-11 at 13.39.04@2x" style="zoom:50%;" />

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.39.26@2x.png" alt="CleanShot 2024-05-11 at 13.39.26@2x" style="zoom:50%;" />

## 保持函数依赖的分解

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.40.17@2x.png" alt="CleanShot 2024-05-11 at 13.40.17@2x" style="zoom:50%;" />

### 如何判断分解是保持函数依赖的

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.44.23@2x.png" alt="CleanShot 2024-05-11 at 13.44.23@2x" style="zoom:50%;" />

### 丢失函数依赖的分解实例

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.44.41@2x.png" alt="CleanShot 2024-05-11 at 13.44.41@2x" style="zoom:50%;" />



## 无损连接分解

### 有损分解的例子

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.45.02@2x.png" alt="CleanShot 2024-05-11 at 13.45.02@2x" style="zoom:50%;" />

### 无损连接分解的定义

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.45.24@2x.png" alt="CleanShot 2024-05-11 at 13.45.24@2x" style="zoom:50%;" />

### 无损连接分解的判别算法

无损连接分解的判别算法考试不要求

### 分解为两个关系模式的无损分解

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.46.08@2x.png" alt="CleanShot 2024-05-11 at 13.46.08@2x" style="zoom:50%;" />

判定算法:

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.46.21@2x.png" alt="CleanShot 2024-05-11 at 13.46.21@2x" style="zoom:50%;" />

 但是其实正向不成立,只能推出多值依赖

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.55.06@2x.png" alt="CleanShot 2024-05-11 at 13.55.06@2x" style="zoom:50%;" />

### 分解为两个关系模式的无损分解示例

 <img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.55.56@2x.png" alt="CleanShot 2024-05-11 at 13.55.56@2x" style="zoom:50%;" />

## 关系模式分解算法

### 保持无损: 分解之后BCNF

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 13.56.38@2x.png" alt="CleanShot 2024-05-11 at 13.56.38@2x" style="zoom:50%;" />

是不是无损的? 是的  

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.04.39@2x.png" alt="CleanShot 2024-05-11 at 14.04.39@2x" style="zoom:50%;" />

#### 例子

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.02.53@2x.png" alt="CleanShot 2024-05-11 at 14.02.53@2x" style="zoom:50%;" />

#### 练习：如何构造一个有N种BCNF分解结果的关系模式

1. <img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.05.48@2x.png" alt="CleanShot 2024-05-11 at 14.05.48@2x" style="zoom:50%;" />
2. <img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.06.03@2x.png" alt="CleanShot 2024-05-11 at 14.06.03@2x" style="zoom:50%;" />

第二种不知道多少, 没讲

### 达到4NF无损连接分解算法

不讲

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.06.51@2x.png" alt="CleanShot 2024-05-11 at 14.06.51@2x" style="zoom:50%;" />

#### 例子

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.08.04@2x.png" alt="CleanShot 2024-05-11 at 14.08.04@2x" style="zoom:50%;" />

### 关于BCNF分解的额外讨论

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.13.20@2x.png" alt="CleanShot 2024-05-11 at 14.13.20@2x" style="zoom:50%;" />

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.13.28@2x.png" alt="CleanShot 2024-05-11 at 14.13.28@2x" style="zoom:50%;" />

左边分解太碎了

### 保持函数依赖的分解: 最高3NF

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.16.08@2x.png" alt="CleanShot 2024-05-11 at 14.16.08@2x" style="zoom:50%;" />

为什么第三点的时候算法终止? 因为此时已经是3NF了

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.29.20@2x.png" alt="CleanShot 2024-05-11 at 14.29.20@2x" style="zoom:50%;" />

如果XA=U, 此时B不可能是违反3NF的例子

#### 丢失函数依赖的BCNF分解

跳过了

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.15.09@2x.png" alt="CleanShot 2024-05-11 at 14.15.09@2x" style="zoom:50%;" />

#### 达到3NF保持函数依赖的分解

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.31.36@2x.png" alt="CleanShot 2024-05-11 at 14.31.36@2x" style="zoom:50%;" />

### 同时保持函数依赖和无损连接的分解

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.33.56@2x.png" alt="CleanShot 2024-05-11 at 14.33.56@2x" style="zoom:50%;" />

不能在保持无损的结果上改进, 很难, 应该在保持函数依赖的结果上改进

#### 同时保持函数依赖和无损连接的分解算法

再加一个表, 代表了原来的码, 可以限定不会出现新的行, 比如给上面的例子加一个表AB

<img src="./7.关系规范化.assets/CleanShot 2024-05-11 at 14.35.41@2x.png" alt="CleanShot 2024-05-11 at 14.35.41@2x" style="zoom:50%;" />

## 模式调优

跳过
