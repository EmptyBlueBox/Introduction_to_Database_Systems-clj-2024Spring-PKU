# 第四章 SQL

## SQL简介

### SQL的起源

SQL: Struceured Query Languang
1974年，由Boyce和Chamber提出，称为Sequel
1975-1979年，在System R上实现，由IBM San Jose研究室研制

### SQL语言的特点

语言简洁，易学易用

面向集合的操作方式：一次一集合

高度非过程化：用户只需提出“做什么”，无须告诉“怎么做”，不必了解存取路径

一体化
集DDL，DML，DCL于一体，单一的结构——关系，带来了数据操作符的统一

两种使用方式，统一的语法结构：既是自含式（用户使用）的，又是嵌入式的（程序员使用）

### SQL的标准化

### SQL主要操作符

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.16.23@2x.png" alt="CleanShot 2024-03-19 at 16.16.23@2x" style="zoom:30%;" />

### SQL：数据访问的事实标准

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.16.43@2x.png" alt="CleanShot 2024-03-19 at 16.16.43@2x" style="zoom:30%;" />

### 约定俗成：提供一个类SQL接口

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.17.07@2x.png" alt="CleanShot 2024-03-19 at 16.17.07@2x" style="zoom:30%;" />

## SQL数据模式定义

### 标准SQL中的数据定义对象

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.19.59@2x.png" alt="CleanShot 2024-03-19 at 16.19.59@2x" style="zoom:30%;" />

### 实际数据库中的定义对象： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.20.13@2x.png" alt="CleanShot 2024-03-19 at 16.20.13@2x" style="zoom:30%;" />

### 术语讨论：模式

MySQL：模式即是数据库

SQL Server：模式把对家和用户分离开来

对象命名：〈数据库〉.〈模式〉.〈表〉

创建模式
create schema < 模式名＞
create schema University.Library

### 数据库定义： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.24.29@2x.png" alt="CleanShot 2024-03-19 at 16.24.29@2x" style="zoom:30%;" />

最简单的创建数据库的命令：create database University
use 命令指定当前要使用的数据库：use University

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.24.55@2x.png" alt="CleanShot 2024-03-19 at 16.24.55@2x" style="zoom:30%;" />

create database ＜ 数据库名＞
[ default character set utf8
default collate utf8_Chinese_ci ]

create database 等同于 create schema

### MySQL表空间

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.27.20@2x.png" alt="CleanShot 2024-03-19 at 16.27.20@2x" style="zoom:30%;" />

### 创建基本表的语法命令

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.27.35@2x.png" alt="CleanShot 2024-03-19 at 16.27.35@2x" style="zoom:40%;" />

#### 创建表示例

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.28.00@2x.png" alt="CleanShot 2024-03-19 at 16.28.00@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.28.10@2x.png" alt="CleanShot 2024-03-19 at 16.28.10@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.28.24@2x.png" alt="CleanShot 2024-03-19 at 16.28.24@2x" style="zoom:40%;" />

### 修改基本表

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.29.06@2x.png" alt="CleanShot 2024-03-19 at 16.29.06@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.29.40@2x.png" alt="CleanShot 2024-03-19 at 16.29.40@2x" style="zoom:40%;" />

### 删除基本表

drop table 表名

drop table不能删除被foreign key约束所引用的表，必须先除去foreign key约束或引用表

任何引用已删除表的视图或存储过程必须通过drop view或drop procedure语句显式除去

DANGER：刪除表定义及该表的所有数据、索引、触发器、约束和权限规范

### 表定义相关的字典表： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.33.29@2x.png" alt="CleanShot 2024-03-19 at 16.33.29@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.33.44@2x.png" alt="CleanShot 2024-03-19 at 16.33.44@2x" style="zoom:40%;" />

### 标准SQL中的信息视图

INFORMATION_ SCHEMA.SCHEMATA
INFORMATION SCHEMA. TABLES
INFORMATION_SCHEMA.COLUMNS
INFORMATION_SCHEMA.CHECK_CONSTRAINTS
INFORMATION_SCHEMA.VIEWS
INFORMATION_SCHEMA.DOMAINS

### MySQL中的信息视图查询

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.34.19@2x.png" alt="CleanShot 2024-03-19 at 16.34.19@2x" style="zoom:30%;" />

### SQL数据定义特点

SQL中，任何时候都可以执行一个数据定义语包，随时修改数据库结构

- 数据库定义不断增长（不必一开始就定义完整）
- 数据库定义随时修改（不必一开始就完全合理）
- 可进行增加索引、撤消索引的实验，检验其效率影响



- 在非关系型数据库系统中，必须在数据库使用前全部完成数据库定义
- 若要修改已投入运行的数据库，则需停下一切数据库活动，卸出数据库，修改数据库定义并重新编译，再按修改后的数据库结构重新装入数据

思考：MySQL是如何实现alter table的？新建一个表，drop旧表

## SQL数据类型定义

### 数据类型全家福

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.35.48@2x.png" alt="CleanShot 2024-03-19 at 16.35.48@2x" style="zoom:30%;" />

### 整型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.36.48@2x.png" alt="CleanShot 2024-03-19 at 16.36.48@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.37.46@2x.png" alt="CleanShot 2024-03-19 at 16.37.46@2x" style="zoom:40%;" />

溢出：

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.44.04@2x.png" alt="CleanShot 2024-03-19 at 16.44.04@2x" style="zoom:40%;" />

宽松模式、严格模式：

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.44.37@2x.png" alt="CleanShot 2024-03-19 at 16.44.37@2x" style="zoom:30%;" />

### 定点数与浮点数

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.44.54@2x.png" alt="CleanShot 2024-03-19 at 16.44.54@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.04@2x.png" alt="CleanShot 2024-03-19 at 16.45.04@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.14@2x.png" alt="CleanShot 2024-03-19 at 16.45.14@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.23@2x.png" alt="CleanShot 2024-03-19 at 16.45.23@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.32@2x.png" alt="CleanShot 2024-03-19 at 16.45.32@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.43@2x.png" alt="CleanShot 2024-03-19 at 16.45.43@2x" style="zoom:30%;" />

### money数据类型

money使用4位小数存储数据，容易发生小数的舍入错误

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.57@2x.png" alt="CleanShot 2024-03-19 at 16.45.57@2x" style="zoom:30%;" />

### 如何给女朋友解释为什么计算机中0.2+ 0.2 +0.1 不等于 0.3 ？

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.46.35@2x.png" alt="CleanShot 2024-03-19 at 16.46.35@2x" style="zoom:30%;" />

### 字符型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.46.49@2x.png" alt="CleanShot 2024-03-19 at 16.46.49@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.46.59@2x.png" alt="CleanShot 2024-03-19 at 16.46.59@2x" style="zoom:30%;" />

#### 定义者的选择： char or varchar ?

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.47.27@2x.png" alt="CleanShot 2024-03-19 at 16.47.27@2x" style="zoom:30%;" />

变长之利：减少存储开销 ＋ 元组数/页 高

变长之弊：查询计算偏移 ＋ 更新挪移数据

变长之用：长短显著不一+ 很少发生变化

### 字符集

字符集（character set）：字符＋编码

字符序（collation）：字符比较规则
•宇符按其编码比较大小
•如果两个字符为大小写关系，则它们相等

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.48.41@2x.png" alt="CleanShot 2024-03-19 at 16.48.41@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.49.11@2x.png" alt="CleanShot 2024-03-19 at 16.49.11@2x" style="zoom:30%;" />

### 日期型数据类型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.51.27@2x.png" alt="CleanShot 2024-03-19 at 16.51.27@2x" style="zoom:30%;" />

使用：

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.03@2x.png" alt="CleanShot 2024-03-19 at 16.55.03@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.16@2x.png" alt="CleanShot 2024-03-19 at 16.55.16@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.29@2x.png" alt="CleanShot 2024-03-19 at 16.55.29@2x" style="zoom:30%;" />

UNIX时间戳

### 日期类型：SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.46@2x.png" alt="CleanShot 2024-03-19 at 16.55.46@2x" style="zoom:30%;" />

格里高利改历法

### 枚举型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.56.32@2x.png" alt="CleanShot 2024-03-19 at 16.56.32@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.56.41@2x.png" alt="CleanShot 2024-03-19 at 16.56.41@2x" style="zoom:30%;" />

### 二进制类型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.56.54@2x.png" alt="CleanShot 2024-03-19 at 16.56.54@2x" style="zoom:30%;" />

### 显式数据类型转换

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.57.29@2x.png" alt="CleanShot 2024-03-19 at 16.57.29@2x" style="zoom:30%;" />

### 隐式数据类型转换

如果不指定显式类型转换，那么在对两个不同数据类型的列值进行运算时，系统会进行隐式类型转换，也即先将它们转换为同一个数据类型，然后再进行运算

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.57.47@2x.png" alt="CleanShot 2024-03-19 at 16.57.47@2x" style="zoom:30%;" />

### 用户定义数据类型 UDDT:User-defined datatype

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.58.01@2x.png" alt="CleanShot 2024-03-19 at 16.58.01@2x" style="zoom:30%;" />

### 用户定义数据类型： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.58.16@2x.png" alt="CleanShot 2024-03-19 at 16.58.16@2x" style="zoom:30%;" />

### 特殊类型

XML
JSON
空间数据
数据类型决定了数据库适用范围，如果数据库不支持日期类型会怎样？

### Oracle中如何表示复杂实体？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.35.18@2x.png" alt="CleanShot 2024-03-24 at 14.35.18@2x" style="zoom:30%;" />

### rowversion 数据类型

如果表中有一列被声明为rowversion，只要行被修改，其rowversion列就会发生改变。它是跨表唯一的，任何表的修改都会使该值递增

可以检测出一行记录是否被别人修改过

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.37.25@2x.png" alt="CleanShot 2024-03-24 at 14.37.25@2x" style="zoom:40%;" />

### uniqueidentifier 数据类型

uniqueidentifier() 产生跨数据库和服务器的全局唯一标识符（GUID）
newid() 函数产生uniqueidentifier 类型的值
newsequentialid() 产生的GUID总是大于先前通过该函数生成的GUID

select newid0）的输出结果如下：DD64B592-D477-4114-8131-32E9FCB540FA

#### 冗长主码的危害

如果使用UUID作为主码

保证其惟一性必须进行字符匹配

一个表的主码经常是另外一个表的外码，而外码是对主码的复制，冗长的主码加上外码会占据很大的表空间

表连接一般是基于主外码的，为加快查询会在主外码上建立索引，冗长主码会使得一个页面里容纳很少的索引项，从而增加查找数据时的磁盘IO 数

### MySQL中的自增字段

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.39.42@2x.png" alt="CleanShot 2024-03-24 at 14.39.42@2x" style="zoom:40%;" />

自增不保证唯一，不一定是主码

### SQL Server中的序列号：identity

identity [(seed, increment)]

为没有有效主码的表提供计数器，有一个起始数（种子），增量值（步长）

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.42.30@2x.png" alt="CleanShot 2024-03-24 at 14.42.30@2x" style="zoom:50%;" />

### SQL Server中的序列号：sequence

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.42.46@2x.png" alt="CleanShot 2024-03-24 at 14.42.46@2x" style="zoom:30%;" />

## SQL视图和临时表定义

### 视图

视图是命名的、以基本表中导出的虚表，它在物理上并不存在，存在的只是其定义，属于外模式

视图中的数据是以基本表中导出的，每次对视图查询都要重新计算

视图之上可以再定义视图

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.43.20@2x.png" alt="CleanShot 2024-03-24 at 14.43.20@2x" style="zoom:50%;" />

### 视图的SQL定义

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.43.55@2x.png" alt="CleanShot 2024-03-24 at 14.43.55@2x" style="zoom:50%;" />

视图的属性名缺省为子查询结果中的属性名，也可以显式指明

with check option指明当对视图进行insert，update时，要检查是否满足视图定义中的条件

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.44.07@2x.png" alt="CleanShot 2024-03-24 at 14.44.07@2x" style="zoom:50%;" />

#### 视图定义的示例

定义一个包含计算机系教工基本信息的视图

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.44.35@2x.png" alt="CleanShot 2024-03-24 at 14.44.35@2x" style="zoom:40%;" />

### 基于视图的查询

给出计算机系工资超过1000的教工姓名

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.45.04@2x.png" alt="CleanShot 2024-03-24 at 14.45.04@2x" style="zoom:40%;" />

### 视图定义中的with check option选项

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.45.20@2x.png" alt="CleanShot 2024-03-24 at 14.45.20@2x" style="zoom:40%;" />

如果有 with check option, 那么下面这个就插入不进去

### 视图的优点

个性化服务：简化用户观点，使不同用户可以以不同角度现察同一数据

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.45.44@2x.png" alt="CleanShot 2024-03-24 at 14.45.44@2x" style="zoom:40%;" />

逻辑独立性：视图作为基本表与外模式之间的映象

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.54.16@2x.png" alt="CleanShot 2024-03-24 at 14.54.16@2x" style="zoom:40%;" />

安全性：“知必所需”，限制用户数据的访问范围

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.54.33@2x.png" alt="CleanShot 2024-03-24 at 14.54.33@2x" style="zoom:40%;" />

### 不可更新的视图示例

视图定义中不包括基表主码

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.55.18@2x.png" alt="CleanShot 2024-03-24 at 14.55.18@2x" style="zoom:40%;" />

视图定义中包含聚集函数

对聚集值的更新无法回逆到基表的行上面：

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.56.11@2x.png" alt="CleanShot 2024-03-24 at 14.56.11@2x" style="zoom:40%;" />

视图定义中没有包括连接属性

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.56.44@2x.png" alt="CleanShot 2024-03-24 at 14.56.44@2x" style="zoom:40%;" />

为什么不允许更新不包括连接属性的视图？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.00.54@2x.png" alt="CleanShot 2024-03-24 at 15.00.54@2x" style="zoom:40%;" />

### 视图更新约束

不可更新视图：
select子句中的目标列包含了聚集函数
select子句中使用unique或distinct关键字
select于句中包含经算术表达式计算出来的列
from子句中包含了多个表
包含了group by子句

对于行列子集视图可以更新（视图是以单个基本表使用选择、投影操作导出的，并且包含了基本表的主码）

### 全关系系統准则6：视图更新准则

所有理论上可更新的视图也应该由系统更新，即对视图的更新要求，存在一个算法可以无二义地把更新要求转换为对基本表的更新序列

#### 什么是理论上可更新的视田？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.05.30@2x.png" alt="CleanShot 2024-03-24 at 15.05.30@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.05.45@2x.png" alt="CleanShot 2024-03-24 at 15.05.45@2x" style="zoom:40%;" />

其中中间这个是理论上可更新的，数据库如果不能分辨出它是可以更新的，那么数据库存在问题

### 临时表和内存表

如果语句很复杂，连接太多，可以用临时表分步完成

如果多次用到一个大表的同一部分数据，可以用临时表暂存这部分数据

如果需要综合多个表的数据，形成一个结果，可以考虑用临时表分步汇总这多个表的数据

频繁使用的表可以放在内存中

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.06.17@2x.png" alt="CleanShot 2024-03-24 at 15.06.17@2x" style="zoom:40%;" />

#### 临时表和内存表的对比

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.08.17@2x.png" alt="CleanShot 2024-03-24 at 15.08.17@2x" style="zoom:40%;" />

#### 查询中的临时表

允许在from子旬中使用子查询表达式，这时可将该子查询的结果命名为一个临时表加以引用

（子查询） as 关系名（列名，列名，⋯）

#### 查询中的临时表示例

找出平均成绩及格的学生（不用having子句）

先求每个学生的平均成绩，再从中找出及格的学生

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.09.51@2x.png" alt="CleanShot 2024-03-24 at 15.09.51@2x" style="zoom:50%;" />

### 公用表表达式CTE

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.10.22@2x.png" alt="CleanShot 2024-03-24 at 15.10.22@2x" style="zoom:40%;" />

### values （表值构造器） FOW（行值构造器）

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.12.12@2x.png" alt="CleanShot 2024-03-24 at 15.12.12@2x" style="zoom:40%;" />

## 分区表定义

### 数据分区

把逻辑上统一的数据分割成较小的、可以独立管理的物理单元（分片）进行存储

可接时间、按地区、按业务类型进行数据分割

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.14.38@2x.png" alt="CleanShot 2024-03-24 at 15.14.38@2x" style="zoom:40%;" />

### 数据分区的优点

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.14.53@2x.png" alt="CleanShot 2024-03-24 at 15.14.53@2x" style="zoom:40%;" />

### 一般的分区方式

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.15.12@2x.png" alt="CleanShot 2024-03-24 at 15.15.12@2x" style="zoom:40%;" />

### MySQL支持的表分区类型

create table tb _name.........)
partition by ...

1. range分区

2. list分区
3. columns分区
4. hash分区
5. key分区
6. 子分区

#### MySQL的range分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.16.22@2x.png" alt="CleanShot 2024-03-24 at 15.16.22@2x" style="zoom:40%;" />

#### MySQL的list分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.16.57@2x.png" alt="CleanShot 2024-03-24 at 15.16.57@2x" style="zoom:40%;" />

#### MySQL的常规hash分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.17.16@2x.png" alt="CleanShot 2024-03-24 at 15.17.16@2x" style="zoom:40%;" />

取模运算。假设分区数为4，则有0，1，2，3四个值，对应分区为四个

83模4取余得3，将数据放在第三个分区中

#### MySQL的线性hash分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.17.51@2x.png" alt="CleanShot 2024-03-24 at 15.17.51@2x" style="zoom:50%;" />

1. 计算V=power （2, ceiling（1og（2， 分区数））），假设分区数为4，V=4

2. 对分区键和V-1进行位与运算

假设分区键值为8（10），8（10）与3进行按位与运算得出插入分区是0（2）

#### MySQL的range columns分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.18.49@2x.png" alt="CleanShot 2024-03-24 at 15.18.49@2x" style="zoom:40%;" />

#### MySQL的list columns分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.19.11@2x.png" alt="CleanShot 2024-03-24 at 15.19.11@2x" style="zoom:40%;" />

#### MySQL的key分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.19.25@2x.png" alt="CleanShot 2024-03-24 at 15.19.25@2x" style="zoom:40%;" />

#### MySQL的子分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.19.40@2x.png" alt="CleanShot 2024-03-24 at 15.19.40@2x" style="zoom:40%;" />

### 分区表：SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.20.08@2x.png" alt="CleanShot 2024-03-24 at 15.20.08@2x" style="zoom:40%;" />

## SQL索引定义

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.20.48@2x.png" alt="CleanShot 2024-03-24 at 15.20.48@2x" style="zoom:40%;" />

### 为什么需要索引？

关系表是个无序集合

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.21.14@2x.png" alt="CleanShot 2024-03-24 at 15.21.14@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.21.31@2x.png" alt="CleanShot 2024-03-24 at 15.21.31@2x" style="zoom:40%;" />

### 索引的直观解释

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.21.47@2x.png" alt="CleanShot 2024-03-24 at 15.21.47@2x" style="zoom:40%;" />

### 索引在数据库系统内部的存储结构

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.22.25@2x.png" alt="CleanShot 2024-03-24 at 15.22.25@2x" style="zoom:40%;" />

### 索引在数据库内部的作用

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.22.45@2x.png" alt="CleanShot 2024-03-24 at 15.22.45@2x" style="zoom:40%;" />

### 索引的创建

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.23.06@2x.png" alt="CleanShot 2024-03-24 at 15.23.06@2x" style="zoom:40%;" />

### 索引的删除

drop index 索引名

drop index 语句不适用于通过定义，primary key 或 unique约束创建的索引，它们必须通过除去约束来撤销

### 索引的排序

asC/desC：索引表中索引值的排序次序，缺省为asc

为什么需要降序索引？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.24.33@2x.png" alt="CleanShot 2024-03-24 at 15.24.33@2x" style="zoom:40%;" />

### unique：唯一性索引

不允许表中不同的行在索引列上取相同值

若已有相同值存在，则系统给出相关信息，不建此索引

系统拒绝违背唯一性的插入、更新

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.25.22@2x.png" alt="CleanShot 2024-03-24 at 15.25.22@2x" style="zoom:40%;" />

### 创建索引选项：InnoDB_fill_factor

fill_factor指定在创建索引的过程中，各索引页的填满程度

为何索引页要预留空间？如果某个索引页填满，系统就必须花时间拆分该索引页，以便为新行腾出空间，这需要很大开销并造成索引碎片

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.27.52@2x.png" alt="CleanShot 2024-03-24 at 15.27.52@2x" style="zoom:40%;" />

### 索引碎片

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.28.11@2x.png" alt="CleanShot 2024-03-24 at 15.28.11@2x" style="zoom:50%;" />

索引碎片：页面逻辑顺序与物理顺序不一致

Q1：索引碎片的负面影响？ 效率低

Q2：如何消除索引碎片？重建索引

### 聚簇索引

cluster：聚簇索引
表中元组按索引项的值排序并物理地聚簇在一起
一个基本表上只能建一个聚簇索引

聚簇索引使得逻辑访问顺序和物理存储顺序尽可能一致

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.28.50@2x.png" alt="CleanShot 2024-03-24 at 15.28.50@2x" style="zoom:40%;" />

### 组合索引

组合索引：建立在多个属性列上的索引

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.29.21@2x.png" alt="CleanShot 2024-03-24 at 15.29.21@2x" style="zoom:40%;" />

#### 组合索引的用场

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.29.34@2x.png" alt="CleanShot 2024-03-24 at 15.29.34@2x" style="zoom:40%;" />

索引不一定总是快。

因为索引总是使用随机读，随机读远远慢于顺序读。

并且顺序读的速度一直在提高，随机读的速度不怎么提高，这就导致之前如果使用索引最多允许20%随机读，否则就比不用索引慢了，最近只允许2%。

也就是满足条件的表项不能高于2%

那么为什么索引会导致随机读呢？我要在索引中查找，然后再前往原表。所以如果要避免随机读，就要把数据一开始就放在索引中。

##### 下面哪个组合索引效果会更好？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.29.54@2x.png" alt="CleanShot 2024-03-24 at 15.29.54@2x" style="zoom:40%;" />

R(B, A) 更好

把过滤条件更强的放在前面，能够把满足条件的表项限定在更小的下标范围内

### 覆盖索引

把select中的列也包含进索引中，这样就可以完全基于索引回答查询，避免对表的访问

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.30.20@2x.png" alt="CleanShot 2024-03-24 at 15.30.20@2x" style="zoom:50%;" />

与组合索引的差别：B值不出现在索引的中间结点上

### 过滤索引

在索引的定义中加入Where语句，索引中只包括那些满足过滤条件的列值

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.30.51@2x.png" alt="CleanShot 2024-03-24 at 15.30.51@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.31.04@2x.png" alt="CleanShot 2024-03-24 at 15.31.04@2x" style="zoom:40%;" />

### 函数索引

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.31.29@2x.png" alt="CleanShot 2024-03-24 at 15.31.29@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.31.41@2x.png" alt="CleanShot 2024-03-24 at 15.31.41@2x" style="zoom:40%;" />

### 索引的使用说明

一个表上可建多个索引

可以动态地定义索引
随时建立和删除索引

索引可以提高查询效率
耗费空间
降低插入、删除、更新效率

•理想化状态：不允许用户在数据操作中引用索引
• 数据的物理独立性：索引如何使用完全由系统决定

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.32.27@2x.png" alt="CleanShot 2024-03-24 at 15.32.27@2x" style="zoom:50%;" />

### 索引的选择度：建否？

索引的理想选择度=1/索引列的唯一值个数(集势Cardinality (NUM_DISTINCT))

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.33.35@2x.png" alt="CleanShot 2024-03-24 at 15.33.35@2x" style="zoom:50%;" />

A列的索引选择度为0.25 B列的索引选择度为0.5

So Easy：应该在哪些列上建索引？A，哈希冲突少

### 索引的选择度：用否？

索引的实际选择度=查询结果行数/总行数 NUM_ROWS

“=”的索引选择度为1/ NUM_DISTINCT
“<>”的索引选择度是多少？
“>=”的索引选择度是多少？
在分布不均匀的情况，如何估计选择度的大小？

什么时候用索引？什么时候表扫描？满足条件的记录少于整体的2%才启用索引

### 索引的选择

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.34.21@2x.png" alt="CleanShot 2024-03-24 at 15.34.21@2x" style="zoom:40%;" />

代价是磁盘IO次数，读取写入一页算一次

比如sno索引下，查询某个学生所选的课程，需要先读索引页，然后根据这个索引页上的三个索引项去读取SC中对应这三个索引项的三页，总共四次磁盘读

## SQL查询语法成分

Select 目标列
From 数据源表
Where 行过滤
Group by 分组
Having 分组过滤
Union 合并
Order by 输出排序
Limit 输出行数

## SQL基本查询结构

### From 子句：笛卡尔积

select from where between distinct order_by as limit

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 14.24.55@2x.png" alt="CleanShot 2024-03-30 at 14.24.55@2x" style="zoom:30%;" />

#### 找出选修课程的学生姓名、课程名、成绩

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.00.42@2x.png" alt="CleanShot 2024-03-30 at 16.00.42@2x" style="zoom:30%;" />

#### 一个似是而非的查询例子

这是错的

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.10.56@2x.png" alt="CleanShot 2024-03-30 at 16.10.56@2x" style="zoom:50%;" />

上面查询的正确SQL语句

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.11.14@2x.png" alt="CleanShot 2024-03-30 at 16.11.14@2x" style="zoom:50%;" />

#### 利用笛卡尔积快速生成测试数据

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.11.29@2x.png" alt="CleanShot 2024-03-30 at 16.11.29@2x" style="zoom:50%;" />

下面的 select 输出 10000 行

#### SQL返回结果是多集

以下查询不同，因为做了笛卡尔积

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.13.51@2x.png" alt="CleanShot 2024-03-30 at 16.13.51@2x" style="zoom:50%;" />

### select子句中的目标列形式

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.16.34@2x.png" alt="CleanShot 2024-03-30 at 16.16.34@2x" style="zoom:50%;" />

只输出使用的列，可以增加使用组合索引的机会

#### 给出所有学生的姓名及出生日期

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.18.05@2x.png" alt="CleanShot 2024-03-30 at 16.18.05@2x" style="zoom:50%;" />

• 计算表达式无列名
• 存储年龄属性是个好的设计吗？

#### 将多个列组合为一个目标列

给出每个老师信息的自然语言描述

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.26.46@2x.png" alt="CleanShot 2024-03-30 at 16.26.46@2x" style="zoom:50%;" />

输出行的形式类似：“李明老师的工资是1500，年龄是45，职称是教授”

#### 当目标列取自多个表时，需要显式指明来自哪个关系

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.33.08@2x.png" alt="CleanShot 2024-03-30 at 16.33.08@2x" style="zoom:50%;" />

第一个会输出四行，第二个是错的，第三个是对的

### where子句

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.13.53@2x.png" alt="CleanShot 2024-03-30 at 18.13.53@2x" style="zoom:50%;" />

不同的SQL书写方式有可能在表达上是等价的，但性能会有很大差异

### between子句

between子句：判断表达式的值是否在某范围内

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.14.25@2x.png" alt="CleanShot 2024-03-30 at 18.14.25@2x" style="zoom:50%;" />

使用between替代or，因为between默认使用索引，or默认不使用

### distinct

重复行的处理

SQL缺省为保留重复行，也可用关键字all显式指明若要去掉重复行，可用关键字distinct指明

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.18.36@2x.png" alt="CleanShot 2024-03-30 at 18.18.36@2x" style="zoom:50%;" />

优化小窍门：只在必要时使用distinct

非必要情形：业务上不要求去重，或者可以确定结果不重复

两个表R（A,B），S（A,C），其中A是这两个表的主码，哪些查询中的distinct可以去掉？

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.19.04@2x.png" alt="CleanShot 2024-03-30 at 18.19.04@2x" style="zoom:50%;" />

第一个可以去掉：两个都是主码，两个主码的笛卡尔积不会重复

第二个不能去掉：两个主码做了笛卡尔积，但是只输出一个，就会重复

第三个可以去掉：R: {(1, 1), (2, 1)}; S: {(1, 1), (2, 2)}，RxS: {(1, 1, 1, 1), (2, 1, 1, 1)}，R.A 不会重复

### order by

输出显示顺序

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.34.18@2x.png" alt="CleanShot 2024-03-30 at 18.34.18@2x" style="zoom:50%;" />

对教工按缴纳所得税的多少排序（按输出列的位置编号指定排序列）

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.34.44@2x.png" alt="CleanShot 2024-03-30 at 18.34.44@2x" style="zoom:50%;" />

按年龄顺序输出学生姓名（排序列可以不是输出列）

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.34.59@2x.png" alt="CleanShot 2024-03-30 at 18.34.59@2x" style="zoom:50%;" />

### 更名运算

为关系和属性重新命名，可出现在select和from子句中

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.35.55@2x.png" alt="CleanShot 2024-03-30 at 18.35.55@2x" style="zoom:50%;" />

#### 属性更名

给出所有学生的姓名、性别、出生日期，并按出生日期升序排列

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.36.17@2x.png" alt="CleanShot 2024-03-30 at 18.36.17@2x" style="zoom:50%;" />

#### 关系更名

找出比S1学生选修C1课程成绩高的学生号

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.39.14@2x.png" alt="CleanShot 2024-03-30 at 18.39.14@2x" style="zoom:50%;" />

找出工资比其部门主任工资高的职工

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.39.24@2x.png" alt="CleanShot 2024-03-30 at 18.39.24@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.42.06@2x.png" alt="CleanShot 2024-03-30 at 18.42.06@2x" style="zoom:50%;" />

### 空值

No cat has 12 tails
A cat has one more tail than no cat
Therefore, a cat has 13 tails

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.42.34@2x.png" alt="CleanShot 2024-03-30 at 18.42.34@2x" style="zoom:50%;" />

#### 关于空值的认识

null 表示值未知，所以数据库中允许字段取null，就变成了三值逻辑：true, false, unkown

C.J Date反对把空值引入数据库：
null是标识，不是值
包含null违反了关系定义

Codd提出了两类null
A-Mark null：米知的，墨镜人眼睛的颜色
T-Mark null：不适用的，汽车眼睛的颜色

#### 数据库中NULL的应用场景

null表示“天意义”：当实体在某个属性上没有值时设为null
null表示“值未知”：值存在，但目前没有获得该信息c

employees (ename, Id _number, degree,..)

- 如果目前不知道职工身份证号码，则设ld_number _number值为null，是为A-Mark null
- 若某位员工没有学位，则在degree列上取值为null，是为T-Mark null

#### 为什么数据库需要NULL？

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.47.41@2x.png" alt="CleanShot 2024-03-30 at 18.47.41@2x" style="zoom:50%;" />

#### 全关系系统准则3：空值的系统化处理

全关系型DBMS应支持空值概念，并用系统化的方式处理空值

模式层面，是否允许列为null？

存储层面，如何表达某个列值为null？

查询层面，不同算子对null的处理逻辑：where、group by、distinct、order by、aggregation、in, exists
#### 空值的逻辑计算

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.50.15@2x.png" alt="CleanShot 2024-03-30 at 18.50.15@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.52.33@2x.png" alt="CleanShot 2024-03-30 at 18.52.33@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.54.19@2x.png" alt="CleanShot 2024-03-30 at 18.54.19@2x" style="zoom:50%;" />

#### 俄底修斯：我叫nobody

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.03.32@2x.png" alt="CleanShot 2024-03-30 at 19.03.32@2x" style="zoom:50%;" />

但是 (s1, p1) 也应该输出，因为无论null是什么，必然满足两个情况之一

分析一下上面查询结果的合理性：

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.05.28@2x.png" alt="CleanShot 2024-03-30 at 19.05.28@2x" style="zoom:50%;" />

但是客观来讲，Pl.city虽目前未知，但肯定是或不是Paris，总会满足查询条件之一

#### 如何判断两个NULL行的相等性？

如前所述，在Where null=null中，其判断结果还是null

问题：对于两行｛null,null｝，涉及到一些诸如distinct, group by算符时，系统需要给出明确判定到底是否是同一行，所以数据库会认为null是一个相同的数

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.06.14@2x.png" alt="CleanShot 2024-03-30 at 19.06.14@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.06.24@2x.png" alt="CleanShot 2024-03-30 at 19.06.24@2x" style="zoom:50%;" />

#### 空值测试

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.11.45@2x.png" alt="CleanShot 2024-03-30 at 19.11.45@2x" style="zoom:50%;" />

注意事项

- 除is ［not］null之外，空值不满足任何查找条件
- 如果null参与算术运算，则该算术表达式的值为null
- 如果null参与比较运算，则结果可视为unknown

空值测试的例子

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.12.26@2x.png" alt="CleanShot 2024-03-30 at 19.12.26@2x" style="zoom:50%;" />

#### 佚名：吃霸王餐的Raven Felix Null

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.13.50@2x.png" alt="CleanShot 2024-03-30 at 19.13.50@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.14.26@2x.png" alt="CleanShot 2024-03-30 at 19.14.26@2x" style="zoom:50%;" />

#### MySQL中的空值处理函数

- isnull （expr）：如果 expr值为空，返回1，否则返回0
- ifnull (check_expr, replace_value): 如果 check_expr值为空，返回replace_Value ；否则 返回check_expr
- nullif （expr1, expr2）：如果两个表达式相等则返回空值，否则返回第一个表达式
- coalesce （expr1, expr2，... ）：返回第一个不为null 的expr

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.15.52@2x.png" alt="CleanShot 2024-03-30 at 19.15.52@2x" style="zoom:50%;" />

最后一个返回的是第三个表达式的值

#### 空值处理函数

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.17.04@2x.png" alt="CleanShot 2024-03-30 at 19.17.04@2x" style="zoom:50%;" />

#### 空值的排序处理

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.17.15@2x.png" alt="CleanShot 2024-03-30 at 19.17.15@2x" style="zoom:50%;" />

null是一个极小值：当指定Order by时，asc首先输出空值，desc最后输出空值

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.18.00@2x.png" alt="CleanShot 2024-03-30 at 19.18.00@2x" style="zoom:50%;" />

如果要求首先输出空值，然后由大到小输出非空值怎么办？

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.18.11@2x.png" alt="CleanShot 2024-03-30 at 19.18.11@2x" style="zoom:50%;" />

附加一个 is_null ，先按照它排序

### 连接运算

连接成分：

1. 两个输入关系
2. 连接条件：决定两个关系中哪些元组相互匹配，以及连接结果中出现哪些属性
3. 连接类型：决定如何处理与连接条件不匹配的元组

关系的连接类型:

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.46.08@2x.png" alt="CleanShot 2024-03-30 at 19.46.08@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.49.55@2x.png" alt="CleanShot 2024-03-30 at 19.49.55@2x" style="zoom:50%;" />

#### inner join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.50.47@2x.png" alt="CleanShot 2024-03-30 at 19.50.47@2x" style="zoom:50%;" />

#### left join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.50.59@2x.png" alt="CleanShot 2024-03-30 at 19.50.59@2x" style="zoom:50%;" />

#### right join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.51.11@2x.png" alt="CleanShot 2024-03-30 at 19.51.11@2x" style="zoom:50%;" />

#### left join excluding inner join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.51.28@2x.png" alt="CleanShot 2024-03-30 at 19.51.28@2x" style="zoom:50%;" />

#### full join excluding inner join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.55.58@2x.png" alt="CleanShot 2024-03-30 at 19.55.58@2x" style="zoom:50%;" />

#### cross join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.56.12@2x.png" alt="CleanShot 2024-03-30 at 19.56.12@2x" style="zoom:50%;" />

#### natural join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.56.26@2x.png" alt="CleanShot 2024-03-30 at 19.56.26@2x" style="zoom:50%;" />

#### straight join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.56.41@2x.png" alt="CleanShot 2024-03-30 at 19.56.41@2x" style="zoom:50%;" />

强制 tbA 作为驱动表，驱动表是在循环外面的，驱动表越小越好

#### 多表连接

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.59.51@2x.png" alt="CleanShot 2024-03-30 at 19.59.51@2x" style="zoom:50%;" />

#### cross apply 与 outer apply

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.02.22@2x.png" alt="CleanShot 2024-03-30 at 20.02.22@2x" style="zoom:50%;" />

查询每位顾客购买数量排在前2位的商品

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.02.34@2x.png" alt="CleanShot 2024-03-30 at 20.02.34@2x" style="zoom:50%;" />

对customer表的每一行与buy表进行匹配

#### 不用外连接表达查询的例子

列出所有老师的教工号、姓名、工资、所教课程号

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.47.32@2x.png" alt="CleanShot 2024-03-30 at 19.47.32@2x" style="zoom:50%;" />

#### 用外连接表达查询的例子

列出所有老师的教工号、姓名、工资、所教课程号

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.49.39@2x.png" alt="CleanShot 2024-03-30 at 19.49.39@2x" style="zoom:50%;" />

### 集合运算

#### 集合运算的几个要点

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.06.48@2x.png" alt="CleanShot 2024-03-30 at 20.06.48@2x" style="zoom:50%;" />

要点一：集合操作缺省去除重复元组
要点二：intersect的优先级高于其他集合操作的优先级

#### 集合操作

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.07.07@2x.png" alt="CleanShot 2024-03-30 at 20.07.07@2x" style="zoom:50%;" />

#### 集合操作表达查询的例子

求工资大于1000或者年龄大于60的教工

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.07.50@2x.png" alt="CleanShot 2024-03-30 at 20.07.50@2x" style="zoom:50%;" />

问题1：等价否？不等价，union all 不去重

问题2：谁更有效？就是考虑有没有机会使用索引，union all分开写使用索引，or不使用索引

其实 union 比 union all慢多了，因为去重很慢

#### 用集合运算实现除法：选修所有课程的同学

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.12.41@2x.png" alt="CleanShot 2024-03-30 at 20.12.41@2x" style="zoom:50%;" />

### 聚集函数

将一列中所有的值聚集为单个值

平均值：avg
最小值：min
最大值：maX
总和：Sum
记数：count

#### 关于聚集函数最容易犯的语法错误

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.17.20@2x.png" alt="CleanShot 2024-03-30 at 20.17.20@2x" style="zoom:50%;" />

这个错误发生的原因是由于在SQL语句中对max()函数的使用不当造成的。

在SQL中,max()是一个聚合函数,用于从一组值中返回最大值。但是,聚合函数不能直接在WHERE子句中使用,因为WHERE子句在聚合之前进行数据过滤。

修改后的SQL语句应该是:

```sql
select sno
from SC
where grade =
	(select max( grade )
	from SC)
```

#### 聚集函数关于nul的处理： 除count（*）外忽略nul

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.22.26@2x.png" alt="CleanShot 2024-03-30 at 20.22.26@2x" style="zoom:50%;" />

#### 统计型聚集函数

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.23.26@2x.png" alt="CleanShot 2024-03-30 at 20.23.26@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.23.42@2x.png" alt="CleanShot 2024-03-30 at 20.23.42@2x" style="zoom:50%;" />

### 分组运算

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.23.54@2x.png" alt="CleanShot 2024-03-30 at 20.23.54@2x" style="zoom:50%;" />

#### 分组查询的应用场景

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.24.09@2x.png" alt="CleanShot 2024-03-30 at 20.24.09@2x" style="zoom:50%;" />

#### 分组查询的实例展示

列出每个学生的平均成绩，将SC按sno分组，再对每个分组求平均成绩

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.25.13@2x.png" alt="CleanShot 2024-03-30 at 20.25.13@2x" style="zoom:50%;" />

列出每门课程的平均成绩，将SC按cno分组，再对每个分组求平均成绩

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.25.35@2x.png" alt="CleanShot 2024-03-30 at 20.25.35@2x" style="zoom:50%;" />

#### 分组的语法形式

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.26.08@2x.png" alt="CleanShot 2024-03-30 at 20.26.08@2x" style="zoom:50%;" />

#### 分组语法正确性要点：目标列必须是分组列

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.34.42@2x.png" alt="CleanShot 2024-03-30 at 20.34.42@2x" style="zoom:50%;" />

Select 后面的必须是 group 后面的子集

#### 分组的查询示例

列出每个学生的最高、最低、平均成绩

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.36.32@2x.png" alt="CleanShot 2024-03-30 at 20.36.32@2x" style="zoom:50%;" />

#### 比较两个外观类似的查询

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.38.42@2x.png" alt="CleanShot 2024-03-30 at 20.38.42@2x" style="zoom:50%;" />

列出每一年龄组中男学生（超过50人）的人数

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.38.52@2x.png" alt="CleanShot 2024-03-30 at 20.38.52@2x" style="zoom:50%;" />

执行顺序：

Where -> group by -> having

#### LeetCode1748：求唯一元素之和

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.40.24@2x.png" alt="CleanShot 2024-03-30 at 20.40.24@2x" style="zoom:50%;" />

#### group_concat：串接字称串

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.40.43@2x.png" alt="CleanShot 2024-03-30 at 20.40.43@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.41.57@2x.png" alt="CleanShot 2024-03-30 at 20.41.57@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.42.07@2x.png" alt="CleanShot 2024-03-30 at 20.42.07@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.42.19@2x.png" alt="CleanShot 2024-03-30 at 20.42.19@2x" style="zoom:50%;" />

### 从 group by 到 cube

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.43.08@2x.png" alt="CleanShot 2024-03-30 at 20.43.08@2x" style="zoom:50%;" />

#### 所有可能的分析需求

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.43.30@2x.png" alt="CleanShot 2024-03-30 at 20.43.30@2x" style="zoom:50%;" />

使用cube

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.44.34@2x.png" alt="CleanShot 2024-03-30 at 20.44.34@2x" style="zoom:50%;" />

#### cube的使用语法

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.44.54@2x.png" alt="CleanShot 2024-03-30 at 20.44.54@2x" style="zoom:50%;" />

总行数：每一个列在cube之后都可以取n+1种值，+1是因为多了一个 ALL 值

### rollup

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.15.13@2x.png" alt="CleanShot 2024-04-06 at 19.15.13@2x" style="zoom:50%;" />

#### roll up 的使用语法

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.18.33@2x.png" alt="CleanShot 2024-04-06 at 19.18.33@2x" style="zoom:50%;" />

#### 总行数

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.18.52@2x.png" alt="CleanShot 2024-04-06 at 19.18.52@2x" style="zoom:50%;" />

a (b(c+1)+1)+1

跟列顺序有关系

### group by与null的关系

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.20.28@2x.png" alt="CleanShot 2024-04-06 at 19.20.28@2x" style="zoom:50%;" />

结论一：group by将多个null行视同一个分组

结论二：count（*）会将null纳入计数，其他聚集函数忽略null （比如 count(B) ）

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.20.50@2x.png" alt="CleanShot 2024-04-06 at 19.20.50@2x" style="zoom:50%;" />

#### 如何区分原表本生null与分组派生null？

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.27.44@2x.png" alt="CleanShot 2024-04-06 at 19.27.44@2x" style="zoom:50%;" />

圈起来的这两个地方是不同含义的null，第一个代表原始表中的null，第二个代表A=1的总计

#### 通过grouping函数识别分组聚合行

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.35.31@2x.png" alt="CleanShot 2024-04-06 at 19.35.31@2x" style="zoom:50%;" />

代表A=1的总计行，会被新的列打上一个1的tag

#### 通过grouping过滤掉非聚合行

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.37.29@2x.png" alt="CleanShot 2024-04-06 at 19.37.29@2x" style="zoom:50%;" />

#### 在报表中识别原始null与派生null的例子

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.37.43@2x.png" alt="CleanShot 2024-04-06 at 19.37.43@2x" style="zoom:50%;" />

#### 如何标识合并报表中行的分组归属？

grouping() 函数可以标示每一行到底和哪个group by 相关联，这是通过为不同的分组分配不同的整数来做到的

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.40.05@2x.png" alt="CleanShot 2024-04-06 at 19.40.05@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.40.22@2x.png" alt="CleanShot 2024-04-06 at 19.40.22@2x" style="zoom:50%;" />

#### 在报表中识别行的分组归属

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 19.40.46@2x.png" alt="CleanShot 2024-04-06 at 19.40.46@2x" style="zoom:50%;" />

#### 如何生成多个分组语包的合并报表？

繁琐低效

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.24.10@2x.png" alt="CleanShot 2024-04-06 at 20.24.10@2x" style="zoom:50%;" />

1. 很麻烦
2. 性能差：union性能差、多个group by是重复计算扫描同一个表，不能利用已经计算过的数据

### 分组属性集

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.24.44@2x.png" alt="CleanShot 2024-04-06 at 20.24.44@2x" style="zoom:50%;" />

#### 使用方法

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.28.45@2x.png" alt="CleanShot 2024-04-06 at 20.28.45@2x" style="zoom:50%;" />

#### 产生分组属性集的代数操作

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.29.04@2x.png" alt="CleanShot 2024-04-06 at 20.29.04@2x" style="zoom:50%;" />



## 嵌套子查询

in, some/all, exists

### 典型的子查询错误

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.30.02@2x.png" alt="CleanShot 2024-04-06 at 20.30.02@2x" style="zoom:50%;" />

第二个报错，因为有两行两个数字，一个数字不能等于两个数字

### 集合成员资格（in子查询）

表达式 ［not］in（子查询）

判断表达式的值是否在子查询的结果中

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.33.32@2x.png" alt="CleanShot 2024-04-06 at 20.33.32@2x" style="zoom:50%;" />

#### 列出选修了C1号课程的学生的姓名

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.33.50@2x.png" alt="CleanShot 2024-04-06 at 20.33.50@2x" style="zoom:50%;" />

问题1：等价否？

现代数据库，等价

问题2：谁更有效？

现代数据库，会把第二个转化成第一个，一样有效，因为如果按照第二个的算法，会给子查询的结果排序，排序很耗时

#### 列出选修了C1号和C2号课程的学生的学号

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.37.36@2x.png" alt="CleanShot 2024-04-06 at 20.37.36@2x" style="zoom:50%;" />

该查询的思路是什么？使用连接操作该如何表达？

子查询找选了c2的人，外层查询找选了c1的人

使用连接完成：

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.39.06@2x.png" alt="CleanShot 2024-04-06 at 20.39.06@2x" style="zoom:50%;" />

### 集合之间的比较（some/all子查询）

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.39.20@2x.png" alt="CleanShot 2024-04-06 at 20.39.20@2x" style="zoom:50%;" />

#### 使用例子

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.45.27@2x.png" alt="CleanShot 2024-04-06 at 20.45.27@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.45.43@2x.png" alt="CleanShot 2024-04-06 at 20.45.43@2x" style="zoom:50%;" />

#### 找出平均成绩最高的学生号

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.45.59@2x.png" alt="CleanShot 2024-04-06 at 20.45.59@2x" style="zoom:50%;" />

#### 找出每个系平均成绩最高的学生

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.47.01@2x.png" alt="CleanShot 2024-04-06 at 20.47.01@2x" style="zoom:50%;" />

第三行应该是 S.sno=SC.sno

### 集合基数的测试（exists子查询）

判断一个子查询的结果是不是一个空集

［not］ exists（子查询）

判断子查询的结果集合中是否有任何元组存在



in后的子查询与外层查询无关，每个子查询只执行一次，称其为无关子查询

exists后的子查询与外层查询有关，每个子查询需要执行多次，称之为相关子查询

#### exists表达查询的思路：列出选修了C1号课程的学生姓名

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.51.07@2x.png" alt="CleanShot 2024-04-06 at 20.51.07@2x" style="zoom:50%;" />

#### 列出选修了C1号和C2号课程的学生的学号

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.52.43@2x.png" alt="CleanShot 2024-04-06 at 20.52.43@2x" style="zoom:50%;" />

### 反半连接：not in, not exists

列出没有选修课程的学生的姓名

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.54.40@2x.png" alt="CleanShot 2024-04-06 at 20.54.40@2x" style="zoom:50%;" />

#### 反半连接的其他实现途径

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.55.02@2x.png" alt="CleanShot 2024-04-06 at 20.55.02@2x" style="zoom:50%;" />

### 除法在SQL中的表达

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.55.22@2x.png" alt="CleanShot 2024-04-06 at 20.55.22@2x" style="zoom:50%;" />

#### 双重否定导致的亨普尔悖论

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.55.43@2x.png" alt="CleanShot 2024-04-06 at 20.55.43@2x" style="zoom:50%;" />

#### 列出选修了全部课程的学生姓名

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 20.57.07@2x.png" alt="CleanShot 2024-04-06 at 20.57.07@2x" style="zoom:50%;" />

#### 列出至少选修了s1号学生选修的所有课程的学生名

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 21.00.01@2x.png" alt="CleanShot 2024-04-06 at 21.00.01@2x" style="zoom:50%;" />

#### 用having count（\*）=（select count（*） from C）实现除法

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 21.09.32@2x.png" alt="CleanShot 2024-04-06 at 21.09.32@2x" style="zoom:50%;" />

这是对的，但是普适性不好

### 子查询中的属性解析匹配

对于子查询中的列，采用就近匹配的原则来解析列属于哪个表，如果在内层表中找不到的话，则会到外层表中尝试去匹配

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 21.11.19@2x.png" alt="CleanShot 2024-04-06 at 21.11.19@2x" style="zoom:50%;" />

左边这个查询，sno是从外面的表里找出来的

为了避免这样的错误，最好随时随地写上表名

### 子查询和空值的关系

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 21.13.24@2x.png" alt="CleanShot 2024-04-06 at 21.13.24@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 21.18.00@2x.png" alt="CleanShot 2024-04-06 at 21.18.00@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 21.18.59@2x.png" alt="CleanShot 2024-04-06 at 21.18.59@2x" style="zoom:50%;" />

 

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 21.18.09@2x.png" alt="CleanShot 2024-04-06 at 21.18.09@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 21.19.09@2x.png" alt="CleanShot 2024-04-06 at 21.19.09@2x" style="zoom:50%;" />



<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.23.09@2x.png" alt="CleanShot 2024-04-06 at 22.23.09@2x" style="zoom:50%;" />

返回结果是一样的，都是A中的1，2

因为T_3啥都没有，不像T_2一样有null

## 字符串与文本操作

Like查询, 正则表达式, 全文索引

### 字符串操作：Like查询

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.24.26@2x.png" alt="CleanShot 2024-04-06 at 22.24.26@2x" style="zoom:50%;" />

#### Like中的转义字符

用escape定义转义字符，以去掉特殊字符的特定含义，使其被作为普通字符看待

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.24.52@2x.png" alt="CleanShot 2024-04-06 at 22.24.52@2x" style="zoom:50%;" />

思考：用什么去匹配\？

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.25.13@2x.png" alt="CleanShot 2024-04-06 at 22.25.13@2x" style="zoom:50%;" />

#### Like操作示例的数据准备

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.27.01@2x.png" alt="CleanShot 2024-04-06 at 22.27.01@2x" style="zoom:50%;" />

#### Like关于字符大小写的处理（跳过）

like默认情况下不区分大小写，当COLLATE=utf8_bin时则区分

like binary区分大小写

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.27.32@2x.png" alt="CleanShot 2024-04-06 at 22.27.32@2x" style="zoom:50%;" />

如何让like在COLLATE=utf8_bin时不区分大小写？

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.27.56@2x.png" alt="CleanShot 2024-04-06 at 22.27.56@2x" style="zoom:50%;" />

#### Like操作示例

列出姓名中含有3个以上字符，且倒数第三个是y，倒数第二个是_的游客

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.28.34@2x.png" alt="CleanShot 2024-04-06 at 22.28.34@2x" style="zoom:50%;" />

列出姓名中包含字母o，且至少包含4个字符的游客

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.28.49@2x.png" alt="CleanShot 2024-04-06 at 22.28.49@2x" style="zoom:50%;" />

其他写法：

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.29.06@2x.png" alt="CleanShot 2024-04-06 at 22.29.06@2x" style="zoom:50%;" />

#### like和索引的关系

在gname上建有索引idx_gname

观察下面查询的执行计划，看谁用到了该索引

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.29.26@2x.png" alt="CleanShot 2024-04-06 at 22.29.26@2x" style="zoom:50%;" />

### 正则表达式 (Regular Expression)

记录文本规则的代码；用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.30.47@2x.png" alt="CleanShot 2024-04-06 at 22.30.47@2x" style="zoom:50%;" />

#### 正则表达式语法查询示例

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.31.02@2x.png" alt="CleanShot 2024-04-06 at 22.31.02@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.31.11@2x.png" alt="CleanShot 2024-04-06 at 22.31.11@2x" style="zoom:50%;" />

#### 常见正则表达式

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.31.28@2x.png" alt="CleanShot 2024-04-06 at 22.31.28@2x" style="zoom:50%;" />

#### 正则表达式查询示例

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.31.42@2x.png" alt="CleanShot 2024-04-06 at 22.31.42@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.31.56@2x.png" alt="CleanShot 2024-04-06 at 22.31.56@2x" style="zoom:50%;" />

#### 用check约束表达正则表达式

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.32.09@2x.png" alt="CleanShot 2024-04-06 at 22.32.09@2x" style="zoom:50%;" />

#### 正则表达式： Oracle

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.32.27@2x.png" alt="CleanShot 2024-04-06 at 22.32.27@2x" style="zoom:50%;" />

家族的第一人在树上被吊死，最后一人则被蚂蚁吃掉

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.32.45@2x.png" alt="CleanShot 2024-04-06 at 22.32.45@2x" style="zoom:50%;" />

### 全文检索

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.33.03@2x.png" alt="CleanShot 2024-04-06 at 22.33.03@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.33.26@2x.png" alt="CleanShot 2024-04-06 at 22.33.26@2x" style="zoom:50%;" />

#### MySQL全文索引

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.33.52@2x.png" alt="CleanShot 2024-04-06 at 22.33.52@2x" style="zoom:50%;" />

#### 全文索引的数据准备

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.34.27@2x.png" alt="CleanShot 2024-04-06 at 22.34.27@2x" style="zoom:50%;" />

#### 全文检索查询示例

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.34.45@2x.png" alt="CleanShot 2024-04-06 at 22.34.45@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.34.56@2x.png" alt="CleanShot 2024-04-06 at 22.34.56@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.35.06@2x.png" alt="CleanShot 2024-04-06 at 22.35.06@2x" style="zoom:50%;" />

#### SQL Server全文检索：创建全文索引

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.35.29@2x.png" alt="CleanShot 2024-04-06 at 22.35.29@2x" style="zoom:50%;" />

#### SQL Server全文检索：查询

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.35.44@2x.png" alt="CleanShot 2024-04-06 at 22.35.44@2x" style="zoom:50%;" />

#### SQL Server创建全文检索的示例

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.36.00@2x.png" alt="CleanShot 2024-04-06 at 22.36.00@2x" style="zoom:50%;" />

#### SQL Server全文检索的查询示例

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.36.27@2x.png" alt="CleanShot 2024-04-06 at 22.36.27@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.36.36@2x.png" alt="CleanShot 2024-04-06 at 22.36.36@2x" style="zoom:50%;" />

### 数据库查询和信息检索的区别

数据库查询需要指明文章名字，搜索引擎只需要给出关键字

## SQL数据更新

### Insert 

#### 如何得到一条语句所影响的行数？

用found_rows（）函数判断Select得到的行数

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.31.32@2x.png" alt="CleanShot 2024-04-07 at 00.31.32@2x" style="zoom:50%;" />

用row_count() 函数判断Update或Delete影响的行数

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.32.01@2x.png" alt="CleanShot 2024-04-07 at 00.32.01@2x" style="zoom:50%;" />

#### 插入操作的命令格式

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.33.37@2x.png" alt="CleanShot 2024-04-07 at 00.33.37@2x" style="zoom:50%;" />

#### 插入显式行

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.34.32@2x.png" alt="CleanShot 2024-04-07 at 00.34.32@2x" style="zoom:50%;" />

思考：salary取何值？如何防止插入带有空值的行？

#### 插入子查询

将平均成绩大于90的学生加入到EXCELLENT中

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.35.17@2x.png" alt="CleanShot 2024-04-07 at 00.35.17@2x" style="zoom:50%;" />

#### replace into：替代主码相同的现有行

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.36.49@2x.png" alt="CleanShot 2024-04-07 at 00.36.49@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.37.00@2x.png" alt="CleanShot 2024-04-07 at 00.37.00@2x" style="zoom:50%;" />

### Delete 

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.38.11@2x.png" alt="CleanShot 2024-04-07 at 00.38.11@2x" style="zoom:50%;" />

#### 删除操作示例

删除王明老师所有的任课记录

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.38.47@2x.png" alt="CleanShot 2024-04-07 at 00.38.47@2x" style="zoom:50%;" />

思考：在这里用in和=有区别吗？如果有多个王明就不行了

#### 演示in和=的不同的实例

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.39.42@2x.png" alt="CleanShot 2024-04-07 at 00.39.42@2x" style="zoom:50%;" />

#### 如何删除重复行中的1个？

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.41.03@2x.png" alt="CleanShot 2024-04-07 at 00.41.03@2x" style="zoom:50%;" />

#### 删除低于平均工资的老师记录

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.41.18@2x.png" alt="CleanShot 2024-04-07 at 00.41.18@2x" style="zoom:50%;" />

思考：是先找到所有符合条件的行一并删除，还是找到一个删除一个？

MySQL不允许从子查询中出现的表中删除数据，错误的删除操作写法：

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.42.49@2x.png" alt="CleanShot 2024-04-07 at 00.42.49@2x" style="zoom:50%;" />

正确的删除操作写法：

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.43.04@2x.png" alt="CleanShot 2024-04-07 at 00.43.04@2x" style="zoom:50%;" />

#### 多表删除操作

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.45.29@2x.png" alt="CleanShot 2024-04-07 at 00.45.29@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.45.43@2x.png" alt="CleanShot 2024-04-07 at 00.45.43@2x" style="zoom:50%;" />

### Truncate 

truncate table 删除表中的所有行，而不记录单个行删除操作

truncate table在功能上与不带Where子句的delete语句相同

truncate table 比 delete速度快，使用的系统和事务日志资源少

auto_increment计数器重置为种子值

#### 更新操作的命令格式

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.47.42@2x.png" alt="CleanShot 2024-04-07 at 00.47.42@2x" style="zoom:50%;" />

#### 将D01系系主任的工资改为该系的平均工资

想当然的错误写法

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.48.28@2x.png" alt="CleanShot 2024-04-07 at 00.48.28@2x" style="zoom:50%;" />

正确的写法

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.48.44@2x.png" alt="CleanShot 2024-04-07 at 00.48.44@2x" style="zoom:50%;" />

#### 当C1课程成绩小于该课程平均成绩时，将其提高5%

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.49.40@2x.png" alt="CleanShot 2024-04-07 at 00.49.40@2x" style="zoom:50%;" />

#### 对于任意1门课程，当某同学该课程的成绩小于该课程的平均成绩时，将其提高5%

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.50.01@2x.png" alt="CleanShot 2024-04-07 at 00.50.01@2x" style="zoom:50%;" />

#### 工资超过2000的缴纳10%所得税，其余的缴纳5%所得税

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.50.39@2x.png" alt="CleanShot 2024-04-07 at 00.50.39@2x" style="zoom:50%;" />

使用case when表达不同条件更新分支：

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.53.42@2x.png" alt="CleanShot 2024-04-07 at 00.53.42@2x" style="zoom:50%;" />

### Update 

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.54.11@2x.png" alt="CleanShot 2024-04-07 at 00.54.11@2x" style="zoom:50%;" />

•在把一组记录加载到表中时，一个经典的挑战是如何识别和处理目标表中已有的记录
•常用的方法是如果某记录不存在，就将它插入；如果存在，就用源表中的数据 更新该记录

需要定义复杂的存储过程来完成一系列INSERT或UPDATE命令，这个技术通常被称为UPSERT

#### 表同步：跟踪购买习惯

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.55.31@2x.png" alt="CleanShot 2024-04-07 at 00.55.31@2x" style="zoom:50%;" />

定期将PurchaseRecOrds表中的信息合并到FactBuyingHabits表中
对于不存在的产品-寄户对，插入新行
对于已存在的产品-容户对，更新最近的购买日期

### Merge

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.57.14@2x.png" alt="CleanShot 2024-04-07 at 00.57.14@2x" style="zoom:50%;" />

#### merge实现业务表到仓库表同步的示例

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.57.37@2x.png" alt="CleanShot 2024-04-07 at 00.57.37@2x" style="zoom:50%;" />

### Output (不讲)

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.58.28@2x.png" alt="CleanShot 2024-04-07 at 00.58.28@2x" style="zoom:50%;" />

#### 自定义审计小助手

<img src="./4.SQL.assets/CleanShot 2024-04-07 at 00.58.52@2x.png" alt="CleanShot 2024-04-07 at 00.58.52@2x" style="zoom:50%;" />

## SQL脚本语言

### 脚本语法

#### 批处理

批处理是包含一个或多个SQL语句的组，从应用程序一次性发送到服务器执行，服务器将批处理语句编译成一个可执行单元

批处理中的错误处理:

1. 编译错误使执行计划无法编译，以而导致批处理中的任何语句均无法执行
2. 大多数运行时错误将停止执行当前语句和其后的语句
3. 少数运行时错误（如违反约束）仅停止执行当前语句，而继续执行批处理中其它所有语句
4. 如果批处理第二条语句在执行时失败，则第一条语句的结果不受影响，因为宅已经执行

#### 批处理中的错误处理

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.52.26@2x.png" alt="CleanShot 2024-04-06 at 22.52.26@2x" style="zoom:50%;" />

#### 局部变量

局部变量是可以保存特定类型的单个数据值的对象

变量通常用于：

1. 作为计数器计算循环执行的次数
2. 保存数据值以供控制流语句测试
3. 保存由存储过程返回代码返回的数据值

变量的声明方式：declare @变量名称 数据类型
变量的赋值方式：set @变量名称= SQL表达式

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.53.43@2x.png" alt="CleanShot 2024-04-06 at 22.53.43@2x" style="zoom:50%;" />

#### 控制流：SQL Server

控制流关键字：用于控制T-SQL语句、语句块和存储过程的执行流，使语句互相连接、关联和依存

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.54.05@2x.png" alt="CleanShot 2024-04-06 at 22.54.05@2x" style="zoom:50%;" />

#### 控制流：MySQL

控制流关键字：用于控制T-SQL语包、语句块和存储过程的执行流，使语句互相连接、关联和依存

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.54.37@2x.png" alt="CleanShot 2024-04-06 at 22.54.37@2x" style="zoom:50%;" />

#### 错误处理：SQL Server

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.55.03@2x.png" alt="CleanShot 2024-04-06 at 22.55.03@2x" style="zoom:50%;" />

如果try部分中的SQL语句出现错误，则转入catch部分进行相应的错误处理

error_number（）：返回错误号
error_severity（）：返回严重性级别
error_state（）：返回错误状态号
error_procedure（）：返回发生错误的存储过程或触发器的名称
error_line（）：返回例程中导致错误的行号
error_message（）：返回描述错误的完整文本信息

#### SQL Server错误处理示例

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.56.06@2x.png" alt="CleanShot 2024-04-06 at 22.56.06@2x" style="zoom:50%;" />

#### SQL与过程化执行方式的差别

阻抗匹配 impedance mismatch
SQL：一次一集合
过程化执行：一次一记录

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.56.37@2x.png" alt="CleanShot 2024-04-06 at 22.56.37@2x" style="zoom:50%;" />

### 游标

游标：在查询结果的记录集合中移动的指针

需要游标的数据操作：当select语句的结果中包含多行时，使用游标可以逐个存取这些行

活动集：select语句返回的行的集合

当前行：活动集中当前处理的那一行游标即是指向当前行的指针

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.57.12@2x.png" alt="CleanShot 2024-04-06 at 22.57.12@2x" style="zoom:50%;" />

#### 游标分类

滚动游标：游标位置可以来回移动，可在活动集中取任意行

非滚动游标：只能在活动集中顺序地取下一行

更新游标：系统对游标指向的当前行加锁，当程序读下一行数据时，本行数据解锁，下一行数据加锁

#### 完整的使用游标的过程

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.57.43@2x.png" alt="CleanShot 2024-04-06 at 22.57.43@2x" style="zoom:50%;" />

#### 游标定义语句

Declare：定义一个游标，使之对应一个select语句

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.58.04@2x.png" alt="CleanShot 2024-04-06 at 22.58.04@2x" style="zoom:50%;" />

insensitive：创建游标使用的数据临时复本，对游标进行提取操作时返回的数据不反映对基表所做的修改

若省略insensitive，对基表提交的更新都会反映在后面的提取中

for update：表示该游标可用于对当前行的修改与删除

open 游标名：

1. 打开一个游标，执行游标对应的查询
2. 结果集合为该游标的活动集

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.59.01@2x.png" alt="CleanShot 2024-04-06 at 22.59.01@2x" style="zoom:50%;" />

在活动集中将游标移到特定的行，取出该行数据放到相应的宿主变量中

close 游标名：

1. 关闭游标，释放活动集及其所占资源
2. 需要再使用该游标时，执行open语句

free 游标名：删除游标，以后不能再对该游标执行Open语句

#### 使用游标的例子：逐行更新

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 22.59.58@2x.png" alt="CleanShot 2024-04-06 at 22.59.58@2x" style="zoom:50%;" />

### 动态SQL：产生SQL的SQL

根据用户的输入构造SQL执行代码

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.00.25@2x.png" alt="CleanShot 2024-04-06 at 23.00.25@2x" style="zoom:50%;" />

#### 创建一个1000列的宽表

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.00.45@2x.png" alt="CleanShot 2024-04-06 at 23.00.45@2x" style="zoom:50%;" />

#### 购物页面的动态筛选器

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.01.03@2x.png" alt="CleanShot 2024-04-06 at 23.01.03@2x" style="zoom:50%;" />

#### 动态筛选器

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.01.24@2x.png" alt="CleanShot 2024-04-06 at 23.01.24@2x" style="zoom:50%;" />

## 存储过程与函数

### 储存过程

存储过程将程序在服务器中预先编译好并存储起来，然后应用程序只需简单地向服务器发出调用该存储过程的请求即可

存储过程的优点：

1. 执行效率高
2. 重复使用
3. 统一的操作流程
4. 维护业务逻辑
5. 安全性

#### 存储过程的执行效率问题

如果存储过程的执行计划是一成不变的，则随着时间推移，该计划有可能变得是次优的、过时的

比如数据分布发生变化，后续创建了索引

随着存储过程输入参数的不同，有可能对应着不同的最优的执行计划

比如一个按性别检索信息的存储过程 get_info （@sex），由于数据的倾斜分布，对于输入‘男'，最好的执行计划是表扫描，而对于输入'女'，最好的执行计划是利用性别列上的过滤索引

#### 存储过程的命令格式：MySQL

create procedure 存储过程名［参数 数据类型］

begin 存储过程SQL体 end

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.04.05@2x.png" alt="CleanShot 2024-04-06 at 23.04.05@2x" style="zoom:50%;" />

执行存储过程：call get_Sname 's01'

#### 嵌套存储过程：利用n！=n *（n-1）！计算阶乘

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.04.49@2x.png" alt="CleanShot 2024-04-06 at 23.04.49@2x" style="zoom:50%;" />

#### 存储过程练习题

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.05.00@2x.png" alt="CleanShot 2024-04-06 at 23.05.00@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.05.07@2x.png" alt="CleanShot 2024-04-06 at 23.05.07@2x" style="zoom:50%;" />

#### 用户定义函数

用户定义函数：用于封装经常执行的逻辑的子例程

用户定义函数与存储过程的区别

1. 存储过程只能返回一个整数值，用户定义函数可以返回各种数据类型值
2. 存储过程可以做任何数据库修改，用户定义函数不可以修改数据库
3. 存储过程只能由exec来执行，不能用在表达式中，用户定义函数可以由exec来执行，也可以用于表达式中或from子句中
4. 存储过程一般用于对数据库修改或设置，用户定义函数则适于提取数据

### 标量函数

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.06.19@2x.png" alt="CleanShot 2024-04-06 at 23.06.19@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.07.03@2x.png" alt="CleanShot 2024-04-06 at 23.07.03@2x" style="zoom:50%;" />

#### 标量函数的调用

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.07.19@2x.png" alt="CleanShot 2024-04-06 at 23.07.19@2x" style="zoom:50%;" />

### 表值函数：SQL Server

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.07.32@2x.png" alt="CleanShot 2024-04-06 at 23.07.32@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.08.40@2x.png" alt="CleanShot 2024-04-06 at 23.08.40@2x" style="zoom:50%;" />

#### Apply操作符与表值函数：SQL Server

apply 可以看成是左右两个表的连接操作，右边的表是一个表值函数的返回结果，该表值函数的输入参数是左边表的某个或者几个列

返回每门课程的成绩排在前三的学生

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.09.15@2x.png" alt="CleanShot 2024-04-06 at 23.09.15@2x" style="zoom:50%;" />

## 触发器定义

触发器是一条语句，当对数据库做修改时，它自动被系统执行

ECA:Event-Condition-Action（事件一条件一动作）
E：指明监视哪些事件：Insert、 delete、update
C： 指明什么条件下触发器被执行
A：指明触发器执行的动作是什么
触发器里有两个动作：所监视的动作、所执行的动作

主动：一切习惯中最好的那个
主动数据库：pull vs push

### 触发器的作用

维护约束：防止在选定一门课后删除该课程

辅助缓存数据维护：当基础表发生改变时更新物化视图

商业规则：向客户发送短信通知其物流信息

监控：传感器感知到一氧化碳浓度级别提高，则开启通风系统

简化应用设计：将核心编程逻辑从异常处理中分离出来

### 行级触发器

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.12.37@2x.png" alt="CleanShot 2024-04-06 at 23.12.37@2x" style="zoom:50%;" />

#### 行级触发器示例

emp（eno, ename, salary, job），要求职工工资增幅不得超过10%

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.13.07@2x.png" alt="CleanShot 2024-04-06 at 23.13.07@2x" style="zoom:50%;" />

#### 行级触发器完成复杂业务处理（教材示例）

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.15.30@2x.png" alt="CleanShot 2024-04-06 at 23.15.30@2x" style="zoom:50%;" />

### 语句级触发器

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.16.29@2x.png" alt="CleanShot 2024-04-06 at 23.16.29@2x" style="zoom:50%;" />

#### 语句级触发器：聚集值作为监视对象时

emp（eno, ename, salary,job），职工平均工资不得低于800

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.17.05@2x.png" alt="CleanShot 2024-04-06 at 23.17.05@2x" style="zoom:50%;" />

### before触发器：处理违反约束的更新

如果插入的成绩不及格，则将其改为60分

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.17.45@2x.png" alt="CleanShot 2024-04-06 at 23.17.45@2x" style="zoom:50%;" />

### 触发器：SQL Server

deleted 和inserted是逻辑（概念）表。这些表在结构上类似于定义触发器的表，用于保存用户操作可能更改的行的旧值或新值

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.18.18@2x.png" alt="CleanShot 2024-04-06 at 23.18.18@2x" style="zoom:50%;" />

触发动作影响到多行时使用游标

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.18.31@2x.png" alt="CleanShot 2024-04-06 at 23.18.31@2x" style="zoom:50%;" />

### 递归触发器

设计触发器，保证部门预算始终等于该部门预算与其所有子部门预算之和

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.18.47@2x.png" alt="CleanShot 2024-04-06 at 23.18.47@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.18.55@2x.png" alt="CleanShot 2024-04-06 at 23.18.55@2x" style="zoom:50%;" />

### 替代触发器

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.19.08@2x.png" alt="CleanShot 2024-04-06 at 23.19.08@2x" style="zoom:50%;" />

#### 替代触发器：按指定意图进行更新

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.19.24@2x.png" alt="CleanShot 2024-04-06 at 23.19.24@2x" style="zoom:50%;" />

#### 替代触发器：更新不可更新的视图

<img src="./4.SQL.assets/CleanShot 2024-04-06 at 23.21.25@2x.png" alt="CleanShot 2024-04-06 at 23.21.25@2x" style="zoom:50%;" />

## 课堂小问答

触发器只能监视单个表上的更新事件，如果监视目标涉及到乡个表该怎么办？比如连接或者交集。
