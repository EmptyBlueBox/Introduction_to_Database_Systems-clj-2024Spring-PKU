# 第四章 SQL

## SQL简介

### SQL的起源

SQL: Struceured Query Languang
1974年，由Boyce和Chamber提出，称为Sequel
1975-1979年，在System R上实现，由IBM San Jose研究室研制

### SQL语言的特点

语言简洁，易学易用

面向集合的操作方式：一次一集合

高度非过程化：用户只需提出“做什么”，无须告诉“怎么做”，不必了解存取路径

一体化
集DDL，DML，DCL于一体，单一的结构——关系，带来了数据操作符的统一

两种使用方式，统一的语法结构：既是自含式（用户使用）的，又是嵌入式的（程序员使用）

### SQL的标准化

### SQL主要操作符

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.16.23@2x.png" alt="CleanShot 2024-03-19 at 16.16.23@2x" style="zoom:30%;" />

### SQL：数据访问的事实标准

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.16.43@2x.png" alt="CleanShot 2024-03-19 at 16.16.43@2x" style="zoom:30%;" />

### 约定俗成：提供一个类SQL接口

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.17.07@2x.png" alt="CleanShot 2024-03-19 at 16.17.07@2x" style="zoom:30%;" />

## SQL数据模式定义

### 标准SQL中的数据定义对象

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.19.59@2x.png" alt="CleanShot 2024-03-19 at 16.19.59@2x" style="zoom:30%;" />

### 实际数据库中的定义对象： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.20.13@2x.png" alt="CleanShot 2024-03-19 at 16.20.13@2x" style="zoom:30%;" />

### 术语讨论：模式

MySQL：模式即是数据库

SQL Server：模式把对家和用户分离开来

对象命名：〈数据库〉.〈模式〉.〈表〉

创建模式
create schema < 模式名＞
create schema University.Library

### 数据库定义： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.24.29@2x.png" alt="CleanShot 2024-03-19 at 16.24.29@2x" style="zoom:30%;" />

最简单的创建数据库的命令：create database University
use 命令指定当前要使用的数据库：use University

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.24.55@2x.png" alt="CleanShot 2024-03-19 at 16.24.55@2x" style="zoom:30%;" />

create database ＜ 数据库名＞
[ default character set utf8
default collate utf8_Chinese_ci ]

create database 等同于 create schema

### MySQL表空间

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.27.20@2x.png" alt="CleanShot 2024-03-19 at 16.27.20@2x" style="zoom:30%;" />

### 创建基本表的语法命令

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.27.35@2x.png" alt="CleanShot 2024-03-19 at 16.27.35@2x" style="zoom:40%;" />

#### 创建表示例

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.28.00@2x.png" alt="CleanShot 2024-03-19 at 16.28.00@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.28.10@2x.png" alt="CleanShot 2024-03-19 at 16.28.10@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.28.24@2x.png" alt="CleanShot 2024-03-19 at 16.28.24@2x" style="zoom:40%;" />

### 修改基本表

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.29.06@2x.png" alt="CleanShot 2024-03-19 at 16.29.06@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.29.40@2x.png" alt="CleanShot 2024-03-19 at 16.29.40@2x" style="zoom:40%;" />

### 删除基本表

drop table 表名

drop table不能删除被foreign key约束所引用的表，必须先除去foreign key约束或引用表

任何引用已删除表的视图或存储过程必须通过drop view或drop procedure语句显式除去

DANGER：刪除表定义及该表的所有数据、索引、触发器、约束和权限规范

### 表定义相关的字典表： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.33.29@2x.png" alt="CleanShot 2024-03-19 at 16.33.29@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.33.44@2x.png" alt="CleanShot 2024-03-19 at 16.33.44@2x" style="zoom:40%;" />

### 标准SQL中的信息视图

INFORMATION_ SCHEMA.SCHEMATA
INFORMATION SCHEMA. TABLES
INFORMATION_SCHEMA.COLUMNS
INFORMATION_SCHEMA.CHECK_CONSTRAINTS
INFORMATION_SCHEMA.VIEWS
INFORMATION_SCHEMA.DOMAINS

### MySQL中的信息视图查询

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.34.19@2x.png" alt="CleanShot 2024-03-19 at 16.34.19@2x" style="zoom:30%;" />

### SQL数据定义特点

SQL中，任何时候都可以执行一个数据定义语包，随时修改数据库结构

- 数据库定义不断增长（不必一开始就定义完整）
- 数据库定义随时修改（不必一开始就完全合理）
- 可进行增加索引、撤消索引的实验，检验其效率影响



- 在非关系型数据库系统中，必须在数据库使用前全部完成数据库定义
- 若要修改已投入运行的数据库，则需停下一切数据库活动，卸出数据库，修改数据库定义并重新编译，再按修改后的数据库结构重新装入数据

思考：MySQL是如何实现alter table的？新建一个表，drop旧表

## SQL数据类型定义

### 数据类型全家福

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.35.48@2x.png" alt="CleanShot 2024-03-19 at 16.35.48@2x" style="zoom:30%;" />

### 整型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.36.48@2x.png" alt="CleanShot 2024-03-19 at 16.36.48@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.37.46@2x.png" alt="CleanShot 2024-03-19 at 16.37.46@2x" style="zoom:40%;" />

溢出：

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.44.04@2x.png" alt="CleanShot 2024-03-19 at 16.44.04@2x" style="zoom:40%;" />

宽松模式、严格模式：

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.44.37@2x.png" alt="CleanShot 2024-03-19 at 16.44.37@2x" style="zoom:30%;" />

### 定点数与浮点数

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.44.54@2x.png" alt="CleanShot 2024-03-19 at 16.44.54@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.04@2x.png" alt="CleanShot 2024-03-19 at 16.45.04@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.14@2x.png" alt="CleanShot 2024-03-19 at 16.45.14@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.23@2x.png" alt="CleanShot 2024-03-19 at 16.45.23@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.32@2x.png" alt="CleanShot 2024-03-19 at 16.45.32@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.43@2x.png" alt="CleanShot 2024-03-19 at 16.45.43@2x" style="zoom:30%;" />

### money数据类型

money使用4位小数存储数据，容易发生小数的舍入错误

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.57@2x.png" alt="CleanShot 2024-03-19 at 16.45.57@2x" style="zoom:30%;" />

### 如何给女朋友解释为什么计算机中0.2+ 0.2 +0.1 不等于 0.3 ？

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.46.35@2x.png" alt="CleanShot 2024-03-19 at 16.46.35@2x" style="zoom:30%;" />

### 字符型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.46.49@2x.png" alt="CleanShot 2024-03-19 at 16.46.49@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.46.59@2x.png" alt="CleanShot 2024-03-19 at 16.46.59@2x" style="zoom:30%;" />

#### 定义者的选择： char or varchar ?

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.47.27@2x.png" alt="CleanShot 2024-03-19 at 16.47.27@2x" style="zoom:30%;" />

变长之利：减少存储开销 ＋ 元组数/页 高

变长之弊：查询计算偏移 ＋ 更新挪移数据

变长之用：长短显著不一+ 很少发生变化

### 字符集

字符集（character set）：字符＋编码

字符序（collation）：字符比较规则
•宇符按其编码比较大小
•如果两个字符为大小写关系，则它们相等

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.48.41@2x.png" alt="CleanShot 2024-03-19 at 16.48.41@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.49.11@2x.png" alt="CleanShot 2024-03-19 at 16.49.11@2x" style="zoom:30%;" />

### 日期型数据类型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.51.27@2x.png" alt="CleanShot 2024-03-19 at 16.51.27@2x" style="zoom:30%;" />

使用：

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.03@2x.png" alt="CleanShot 2024-03-19 at 16.55.03@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.16@2x.png" alt="CleanShot 2024-03-19 at 16.55.16@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.29@2x.png" alt="CleanShot 2024-03-19 at 16.55.29@2x" style="zoom:30%;" />

UNIX时间戳

### 日期类型：SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.46@2x.png" alt="CleanShot 2024-03-19 at 16.55.46@2x" style="zoom:30%;" />

格里高利改历法

### 枚举型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.56.32@2x.png" alt="CleanShot 2024-03-19 at 16.56.32@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.56.41@2x.png" alt="CleanShot 2024-03-19 at 16.56.41@2x" style="zoom:30%;" />

### 二进制类型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.56.54@2x.png" alt="CleanShot 2024-03-19 at 16.56.54@2x" style="zoom:30%;" />

### 显式数据类型转换

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.57.29@2x.png" alt="CleanShot 2024-03-19 at 16.57.29@2x" style="zoom:30%;" />

### 隐式数据类型转换

如果不指定显式类型转换，那么在对两个不同数据类型的列值进行运算时，系统会进行隐式类型转换，也即先将它们转换为同一个数据类型，然后再进行运算

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.57.47@2x.png" alt="CleanShot 2024-03-19 at 16.57.47@2x" style="zoom:30%;" />

### 用户定义数据类型 UDDT:User-defined datatype

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.58.01@2x.png" alt="CleanShot 2024-03-19 at 16.58.01@2x" style="zoom:30%;" />

### 用户定义数据类型： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.58.16@2x.png" alt="CleanShot 2024-03-19 at 16.58.16@2x" style="zoom:30%;" />

### 特殊类型

XML
JSON
空间数据
数据类型决定了数据库适用范围，如果数据库不支持日期类型会怎样？

### Oracle中如何表示复杂实体？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.35.18@2x.png" alt="CleanShot 2024-03-24 at 14.35.18@2x" style="zoom:30%;" />

### rowversion 数据类型

如果表中有一列被声明为rowversion，只要行被修改，其rowversion列就会发生改变。它是跨表唯一的，任何表的修改都会使该值递增

可以检测出一行记录是否被别人修改过

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.37.25@2x.png" alt="CleanShot 2024-03-24 at 14.37.25@2x" style="zoom:40%;" />

### uniqueidentifier 数据类型

uniqueidentifier() 产生跨数据库和服务器的全局唯一标识符（GUID）
newid() 函数产生uniqueidentifier 类型的值
newsequentialid() 产生的GUID总是大于先前通过该函数生成的GUID

select newid0）的输出结果如下：DD64B592-D477-4114-8131-32E9FCB540FA

#### 冗长主码的危害

如果使用UUID作为主码

保证其惟一性必须进行字符匹配

一个表的主码经常是另外一个表的外码，而外码是对主码的复制，冗长的主码加上外码会占据很大的表空间

表连接一般是基于主外码的，为加快查询会在主外码上建立索引，冗长主码会使得一个页面里容纳很少的索引项，从而增加查找数据时的磁盘IO 数

### MySQL中的自增字段

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.39.42@2x.png" alt="CleanShot 2024-03-24 at 14.39.42@2x" style="zoom:40%;" />

自增不保证唯一，不一定是主码

### SQL Server中的序列号：identity

identity [(seed, increment)]

为没有有效主码的表提供计数器，有一个起始数（种子），增量值（步长）

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.42.30@2x.png" alt="CleanShot 2024-03-24 at 14.42.30@2x" style="zoom:50%;" />

### SQL Server中的序列号：sequence

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.42.46@2x.png" alt="CleanShot 2024-03-24 at 14.42.46@2x" style="zoom:30%;" />

## SQL视图和临时表定义

### 视图

视图是命名的、以基本表中导出的虚表，它在物理上并不存在，存在的只是其定义，属于外模式

视图中的数据是以基本表中导出的，每次对视图查询都要重新计算

视图之上可以再定义视图

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.43.20@2x.png" alt="CleanShot 2024-03-24 at 14.43.20@2x" style="zoom:50%;" />

### 视图的SQL定义

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.43.55@2x.png" alt="CleanShot 2024-03-24 at 14.43.55@2x" style="zoom:50%;" />

视图的属性名缺省为子查询结果中的属性名，也可以显式指明

with check option指明当对视图进行insert，update时，要检查是否满足视图定义中的条件

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.44.07@2x.png" alt="CleanShot 2024-03-24 at 14.44.07@2x" style="zoom:50%;" />

#### 视图定义的示例

定义一个包含计算机系教工基本信息的视图

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.44.35@2x.png" alt="CleanShot 2024-03-24 at 14.44.35@2x" style="zoom:40%;" />

### 基于视图的查询

给出计算机系工资超过1000的教工姓名

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.45.04@2x.png" alt="CleanShot 2024-03-24 at 14.45.04@2x" style="zoom:40%;" />

### 视图定义中的with check option选项

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.45.20@2x.png" alt="CleanShot 2024-03-24 at 14.45.20@2x" style="zoom:40%;" />

如果有 with check option, 那么下面这个就插入不进去

### 视图的优点

个性化服务：简化用户观点，使不同用户可以以不同角度现察同一数据

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.45.44@2x.png" alt="CleanShot 2024-03-24 at 14.45.44@2x" style="zoom:40%;" />

逻辑独立性：视图作为基本表与外模式之间的映象

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.54.16@2x.png" alt="CleanShot 2024-03-24 at 14.54.16@2x" style="zoom:40%;" />

安全性：“知必所需”，限制用户数据的访问范围

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.54.33@2x.png" alt="CleanShot 2024-03-24 at 14.54.33@2x" style="zoom:40%;" />

### 不可更新的视图示例

视图定义中不包括基表主码

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.55.18@2x.png" alt="CleanShot 2024-03-24 at 14.55.18@2x" style="zoom:40%;" />

视图定义中包含聚集函数

对聚集值的更新无法回逆到基表的行上面：

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.56.11@2x.png" alt="CleanShot 2024-03-24 at 14.56.11@2x" style="zoom:40%;" />

视图定义中没有包括连接属性

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.56.44@2x.png" alt="CleanShot 2024-03-24 at 14.56.44@2x" style="zoom:40%;" />

为什么不允许更新不包括连接属性的视图？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.00.54@2x.png" alt="CleanShot 2024-03-24 at 15.00.54@2x" style="zoom:40%;" />

### 视图更新约束

不可更新视图：
select子句中的目标列包含了聚集函数
select子句中使用unique或distinct关键字
select于句中包含经算术表达式计算出来的列
from子句中包含了多个表
包含了group by子句

对于行列子集视图可以更新（视图是以单个基本表使用选择、投影操作导出的，并且包含了基本表的主码）

### 全关系系統准则6：视图更新准则

所有理论上可更新的视图也应该由系统更新，即对视图的更新要求，存在一个算法可以无二义地把更新要求转换为对基本表的更新序列

#### 什么是理论上可更新的视田？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.05.30@2x.png" alt="CleanShot 2024-03-24 at 15.05.30@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.05.45@2x.png" alt="CleanShot 2024-03-24 at 15.05.45@2x" style="zoom:40%;" />

其中中间这个是理论上可更新的，数据库如果不能分辨出它是可以更新的，那么数据库存在问题

### 临时表和内存表

如果语句很复杂，连接太多，可以用临时表分步完成

如果多次用到一个大表的同一部分数据，可以用临时表暂存这部分数据

如果需要综合多个表的数据，形成一个结果，可以考虑用临时表分步汇总这多个表的数据

频繁使用的表可以放在内存中

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.06.17@2x.png" alt="CleanShot 2024-03-24 at 15.06.17@2x" style="zoom:40%;" />

#### 临时表和内存表的对比

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.08.17@2x.png" alt="CleanShot 2024-03-24 at 15.08.17@2x" style="zoom:40%;" />

#### 查询中的临时表

允许在from子旬中使用子查询表达式，这时可将该子查询的结果命名为一个临时表加以引用

（子查询） as 关系名（列名，列名，⋯）

#### 查询中的临时表示例

找出平均成绩及格的学生（不用having子句）

先求每个学生的平均成绩，再从中找出及格的学生

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.09.51@2x.png" alt="CleanShot 2024-03-24 at 15.09.51@2x" style="zoom:50%;" />

### 公用表表达式CTE

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.10.22@2x.png" alt="CleanShot 2024-03-24 at 15.10.22@2x" style="zoom:40%;" />

### values （表值构造器） FOW（行值构造器）

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.12.12@2x.png" alt="CleanShot 2024-03-24 at 15.12.12@2x" style="zoom:40%;" />

## 分区表定义

### 数据分区

把逻辑上统一的数据分割成较小的、可以独立管理的物理单元（分片）进行存储

可接时间、按地区、按业务类型进行数据分割

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.14.38@2x.png" alt="CleanShot 2024-03-24 at 15.14.38@2x" style="zoom:40%;" />

### 数据分区的优点

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.14.53@2x.png" alt="CleanShot 2024-03-24 at 15.14.53@2x" style="zoom:40%;" />

### 一般的分区方式

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.15.12@2x.png" alt="CleanShot 2024-03-24 at 15.15.12@2x" style="zoom:40%;" />

### MySQL支持的表分区类型

create table tb _name.........)
partition by ...

1. range分区

2. list分区
3. columns分区
4. hash分区
5. key分区
6. 子分区

#### MySQL的range分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.16.22@2x.png" alt="CleanShot 2024-03-24 at 15.16.22@2x" style="zoom:40%;" />

#### MySQL的list分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.16.57@2x.png" alt="CleanShot 2024-03-24 at 15.16.57@2x" style="zoom:40%;" />

#### MySQL的常规hash分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.17.16@2x.png" alt="CleanShot 2024-03-24 at 15.17.16@2x" style="zoom:40%;" />

取模运算。假设分区数为4，则有0，1，2，3四个值，对应分区为四个

83模4取余得3，将数据放在第三个分区中

#### MySQL的线性hash分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.17.51@2x.png" alt="CleanShot 2024-03-24 at 15.17.51@2x" style="zoom:50%;" />

1. 计算V=power （2, ceiling（1og（2， 分区数））），假设分区数为4，V=4

2. 对分区键和V-1进行位与运算

假设分区键值为8（10），8（10）与3进行按位与运算得出插入分区是0（2）

#### MySQL的range columns分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.18.49@2x.png" alt="CleanShot 2024-03-24 at 15.18.49@2x" style="zoom:40%;" />

#### MySQL的list columns分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.19.11@2x.png" alt="CleanShot 2024-03-24 at 15.19.11@2x" style="zoom:40%;" />

#### MySQL的key分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.19.25@2x.png" alt="CleanShot 2024-03-24 at 15.19.25@2x" style="zoom:40%;" />

#### MySQL的子分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.19.40@2x.png" alt="CleanShot 2024-03-24 at 15.19.40@2x" style="zoom:40%;" />

### 分区表：SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.20.08@2x.png" alt="CleanShot 2024-03-24 at 15.20.08@2x" style="zoom:40%;" />

## SQL索引定义

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.20.48@2x.png" alt="CleanShot 2024-03-24 at 15.20.48@2x" style="zoom:40%;" />

### 为什么需要索引？

关系表是个无序集合

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.21.14@2x.png" alt="CleanShot 2024-03-24 at 15.21.14@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.21.31@2x.png" alt="CleanShot 2024-03-24 at 15.21.31@2x" style="zoom:40%;" />

### 索引的直观解释

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.21.47@2x.png" alt="CleanShot 2024-03-24 at 15.21.47@2x" style="zoom:40%;" />

### 索引在数据库系统内部的存储结构

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.22.25@2x.png" alt="CleanShot 2024-03-24 at 15.22.25@2x" style="zoom:40%;" />

### 索引在数据库内部的作用

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.22.45@2x.png" alt="CleanShot 2024-03-24 at 15.22.45@2x" style="zoom:40%;" />

### 索引的创建

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.23.06@2x.png" alt="CleanShot 2024-03-24 at 15.23.06@2x" style="zoom:40%;" />

### 索引的删除

drop index 索引名

drop index 语句不适用于通过定义，primary key 或 unique约束创建的索引，它们必须通过除去约束来撤销

### 索引的排序

asC/desC：索引表中索引值的排序次序，缺省为asc

为什么需要降序索引？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.24.33@2x.png" alt="CleanShot 2024-03-24 at 15.24.33@2x" style="zoom:40%;" />

### unique：唯一性索引

不允许表中不同的行在索引列上取相同值

若已有相同值存在，则系统给出相关信息，不建此索引

系统拒绝违背唯一性的插入、更新

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.25.22@2x.png" alt="CleanShot 2024-03-24 at 15.25.22@2x" style="zoom:40%;" />

### 创建索引选项：InnoDB_fill_factor

fill_factor指定在创建索引的过程中，各索引页的填满程度

为何索引页要预留空间？如果某个索引页填满，系统就必须花时间拆分该索引页，以便为新行腾出空间，这需要很大开销并造成索引碎片

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.27.52@2x.png" alt="CleanShot 2024-03-24 at 15.27.52@2x" style="zoom:40%;" />

### 索引碎片

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.28.11@2x.png" alt="CleanShot 2024-03-24 at 15.28.11@2x" style="zoom:50%;" />

索引碎片：页面逻辑顺序与物理顺序不一致

Q1：索引碎片的负面影响？ 效率低

Q2：如何消除索引碎片？重建索引

### 聚簇索引

cluster：聚簇索引
表中元组按索引项的值排序并物理地聚簇在一起
一个基本表上只能建一个聚簇索引

聚簇索引使得逻辑访问顺序和物理存储顺序尽可能一致

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.28.50@2x.png" alt="CleanShot 2024-03-24 at 15.28.50@2x" style="zoom:40%;" />

### 组合索引

组合索引：建立在多个属性列上的索引

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.29.21@2x.png" alt="CleanShot 2024-03-24 at 15.29.21@2x" style="zoom:40%;" />

#### 组合索引的用场

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.29.34@2x.png" alt="CleanShot 2024-03-24 at 15.29.34@2x" style="zoom:40%;" />

索引不一定总是快。

因为索引总是使用随机读，随机读远远慢于顺序读。

并且顺序读的速度一直在提高，随机读的速度不怎么提高，这就导致之前如果使用索引最多允许20%随机读，否则就比不用索引慢了，最近只允许2%。

也就是满足条件的表项不能高于2%

那么为什么索引会导致随机读呢？我要在索引中查找，然后再前往原表。所以如果要避免随机读，就要把数据一开始就放在索引中。

##### 下面哪个组合索引效果会更好？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.29.54@2x.png" alt="CleanShot 2024-03-24 at 15.29.54@2x" style="zoom:40%;" />

R(B, A) 更好

把过滤条件更强的放在前面，能够把满足条件的表项限定在更小的下标范围内

### 覆盖索引

把select中的列也包含进索引中，这样就可以完全基于索引回答查询，避免对表的访问

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.30.20@2x.png" alt="CleanShot 2024-03-24 at 15.30.20@2x" style="zoom:50%;" />

与组合索引的差别：B值不出现在索引的中间结点上

### 过滤索引

在索引的定义中加入Where语句，索引中只包括那些满足过滤条件的列值

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.30.51@2x.png" alt="CleanShot 2024-03-24 at 15.30.51@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.31.04@2x.png" alt="CleanShot 2024-03-24 at 15.31.04@2x" style="zoom:40%;" />

### 函数索引

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.31.29@2x.png" alt="CleanShot 2024-03-24 at 15.31.29@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.31.41@2x.png" alt="CleanShot 2024-03-24 at 15.31.41@2x" style="zoom:40%;" />

### 索引的使用说明

一个表上可建多个索引

可以动态地定义索引
随时建立和删除索引

索引可以提高查询效率
耗费空间
降低插入、删除、更新效率

•理想化状态：不允许用户在数据操作中引用索引
• 数据的物理独立性：索引如何使用完全由系统决定

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.32.27@2x.png" alt="CleanShot 2024-03-24 at 15.32.27@2x" style="zoom:50%;" />

### 索引的选择度：建否？

索引的理想选择度=1/索引列的唯一值个数(集势Cardinality (NUM_DISTINCT))

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.33.35@2x.png" alt="CleanShot 2024-03-24 at 15.33.35@2x" style="zoom:50%;" />

A列的索引选择度为0.25 B列的索引选择度为0.5

So Easy：应该在哪些列上建索引？A，哈希冲突少

### 索引的选择度：用否？

索引的实际选择度=查询结果行数/总行数 NUM_ROWS

“=”的索引选择度为1/ NUM_DISTINCT
“<>”的索引选择度是多少？
“>=”的索引选择度是多少？
在分布不均匀的情况，如何估计选择度的大小？

什么时候用索引？什么时候表扫描？满足条件的记录少于整体的2%才启用索引

### 索引的选择

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.34.21@2x.png" alt="CleanShot 2024-03-24 at 15.34.21@2x" style="zoom:40%;" />

代价是磁盘IO次数，读取写入一页算一次

比如sno索引下，查询某个学生所选的课程，需要先读索引页，然后根据这个索引页上的三个索引项去读取SC中对应这三个索引项的三页，总共四次磁盘读

## SQL查询语法成分

Select 目标列
From 数据源表
Where 行过滤
Group by 分组
Having 分组过滤
Union 合并
Order by 输出排序
Limit 输出行数

## SQL基本查询结构

### From 子句：笛卡尔积

select from where between distinct order_by as limit

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 14.24.55@2x.png" alt="CleanShot 2024-03-30 at 14.24.55@2x" style="zoom:30%;" />

#### 找出选修课程的学生姓名、课程名、成绩

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.00.42@2x.png" alt="CleanShot 2024-03-30 at 16.00.42@2x" style="zoom:30%;" />

#### 一个似是而非的查询例子

这是错的

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.10.56@2x.png" alt="CleanShot 2024-03-30 at 16.10.56@2x" style="zoom:50%;" />

上面查询的正确SQL语句

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.11.14@2x.png" alt="CleanShot 2024-03-30 at 16.11.14@2x" style="zoom:50%;" />

#### 利用笛卡尔积快速生成测试数据

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.11.29@2x.png" alt="CleanShot 2024-03-30 at 16.11.29@2x" style="zoom:50%;" />

下面的 select 输出 10000 行

#### SQL返回结果是多集

以下查询不同，因为做了笛卡尔积

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.13.51@2x.png" alt="CleanShot 2024-03-30 at 16.13.51@2x" style="zoom:50%;" />

### select子句中的目标列形式

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.16.34@2x.png" alt="CleanShot 2024-03-30 at 16.16.34@2x" style="zoom:50%;" />

只输出使用的列，可以增加使用组合索引的机会

#### 给出所有学生的姓名及出生日期

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.18.05@2x.png" alt="CleanShot 2024-03-30 at 16.18.05@2x" style="zoom:50%;" />

• 计算表达式无列名
• 存储年龄属性是个好的设计吗？

#### 将多个列组合为一个目标列

给出每个老师信息的自然语言描述

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.26.46@2x.png" alt="CleanShot 2024-03-30 at 16.26.46@2x" style="zoom:50%;" />

输出行的形式类似：“李明老师的工资是1500，年龄是45，职称是教授”

#### 当目标列取自多个表时，需要显式指明来自哪个关系

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 16.33.08@2x.png" alt="CleanShot 2024-03-30 at 16.33.08@2x" style="zoom:50%;" />

第一个会输出四行，第二个是错的，第三个是对的

### where子句

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.13.53@2x.png" alt="CleanShot 2024-03-30 at 18.13.53@2x" style="zoom:50%;" />

不同的SQL书写方式有可能在表达上是等价的，但性能会有很大差异

### between子句

between子句：判断表达式的值是否在某范围内

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.14.25@2x.png" alt="CleanShot 2024-03-30 at 18.14.25@2x" style="zoom:50%;" />

使用between替代or，因为between默认使用索引，or默认不使用

### distinct

重复行的处理

SQL缺省为保留重复行，也可用关键字all显式指明若要去掉重复行，可用关键字distinct指明

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.18.36@2x.png" alt="CleanShot 2024-03-30 at 18.18.36@2x" style="zoom:50%;" />

优化小窍门：只在必要时使用distinct

非必要情形：业务上不要求去重，或者可以确定结果不重复

两个表R（A,B），S（A,C），其中A是这两个表的主码，哪些查询中的distinct可以去掉？

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.19.04@2x.png" alt="CleanShot 2024-03-30 at 18.19.04@2x" style="zoom:50%;" />

第一个可以去掉：两个都是主码，两个主码的笛卡尔积不会重复

第二个不能去掉：两个主码做了笛卡尔积，但是只输出一个，就会重复

第三个可以去掉：R: {(1, 1), (2, 1)}; S: {(1, 1), (2, 2)}，RxS: {(1, 1, 1, 1), (2, 1, 1, 1)}，R.A 不会重复

### order by

输出显示顺序

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.34.18@2x.png" alt="CleanShot 2024-03-30 at 18.34.18@2x" style="zoom:50%;" />

对教工按缴纳所得税的多少排序（按输出列的位置编号指定排序列）

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.34.44@2x.png" alt="CleanShot 2024-03-30 at 18.34.44@2x" style="zoom:50%;" />

按年龄顺序输出学生姓名（排序列可以不是输出列）

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.34.59@2x.png" alt="CleanShot 2024-03-30 at 18.34.59@2x" style="zoom:50%;" />

### 更名运算

为关系和属性重新命名，可出现在select和from子句中

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.35.55@2x.png" alt="CleanShot 2024-03-30 at 18.35.55@2x" style="zoom:50%;" />

#### 属性更名

给出所有学生的姓名、性别、出生日期，并按出生日期升序排列

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.36.17@2x.png" alt="CleanShot 2024-03-30 at 18.36.17@2x" style="zoom:50%;" />

#### 关系更名

找出比S1学生选修C1课程成绩高的学生号

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.39.14@2x.png" alt="CleanShot 2024-03-30 at 18.39.14@2x" style="zoom:50%;" />

找出工资比其部门主任工资高的职工

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.39.24@2x.png" alt="CleanShot 2024-03-30 at 18.39.24@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.42.06@2x.png" alt="CleanShot 2024-03-30 at 18.42.06@2x" style="zoom:50%;" />

### 空值

No cat has 12 tails
A cat has one more tail than no cat
Therefore, a cat has 13 tails

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.42.34@2x.png" alt="CleanShot 2024-03-30 at 18.42.34@2x" style="zoom:50%;" />

#### 关于空值的认识

null 表示值未知，所以数据库中允许字段取null，就变成了三值逻辑：true, false, unkown

C.J Date反对把空值引入数据库：
null是标识，不是值
包含null违反了关系定义

Codd提出了两类null
A-Mark null：米知的，墨镜人眼睛的颜色
T-Mark null：不适用的，汽车眼睛的颜色

#### 数据库中NULL的应用场景

null表示“天意义”：当实体在某个属性上没有值时设为null
null表示“值未知”：值存在，但目前没有获得该信息c

employees (ename, Id _number, degree,..)

- 如果目前不知道职工身份证号码，则设ld_number _number值为null，是为A-Mark null
- 若某位员工没有学位，则在degree列上取值为null，是为T-Mark null

#### 为什么数据库需要NULL？

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.47.41@2x.png" alt="CleanShot 2024-03-30 at 18.47.41@2x" style="zoom:50%;" />

#### 全关系系统准则3：空值的系统化处理

全关系型DBMS应支持空值概念，并用系统化的方式处理空值

模式层面，是否允许列为null？

存储层面，如何表达某个列值为null？

查询层面，不同算子对null的处理逻辑：where、group by、distinct、order by、aggregation、in, exists
#### 空值的逻辑计算

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.50.15@2x.png" alt="CleanShot 2024-03-30 at 18.50.15@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.52.33@2x.png" alt="CleanShot 2024-03-30 at 18.52.33@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 18.54.19@2x.png" alt="CleanShot 2024-03-30 at 18.54.19@2x" style="zoom:50%;" />

#### 俄底修斯：我叫nobody

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.03.32@2x.png" alt="CleanShot 2024-03-30 at 19.03.32@2x" style="zoom:50%;" />

但是 (s1, p1) 也应该输出，因为无论null是什么，必然满足两个情况之一

分析一下上面查询结果的合理性：

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.05.28@2x.png" alt="CleanShot 2024-03-30 at 19.05.28@2x" style="zoom:50%;" />

但是客观来讲，Pl.city虽目前未知，但肯定是或不是Paris，总会满足查询条件之一

#### 如何判断两个NULL行的相等性？

如前所述，在Where null=null中，其判断结果还是null

问题：对于两行｛null,null｝，涉及到一些诸如distinct, group by算符时，系统需要给出明确判定到底是否是同一行，所以数据库会认为null是一个相同的数

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.06.14@2x.png" alt="CleanShot 2024-03-30 at 19.06.14@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.06.24@2x.png" alt="CleanShot 2024-03-30 at 19.06.24@2x" style="zoom:50%;" />

#### 空值测试

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.11.45@2x.png" alt="CleanShot 2024-03-30 at 19.11.45@2x" style="zoom:50%;" />

注意事项

- 除is ［not］null之外，空值不满足任何查找条件
- 如果null参与算术运算，则该算术表达式的值为null
- 如果null参与比较运算，则结果可视为unknown

空值测试的例子

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.12.26@2x.png" alt="CleanShot 2024-03-30 at 19.12.26@2x" style="zoom:50%;" />

#### 佚名：吃霸王餐的Raven Felix Null

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.13.50@2x.png" alt="CleanShot 2024-03-30 at 19.13.50@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.14.26@2x.png" alt="CleanShot 2024-03-30 at 19.14.26@2x" style="zoom:50%;" />

#### MySQL中的空值处理函数

- isnull （expr）：如果 expr值为空，返回1，否则返回0
- ifnull (check_expr, replace_value): 如果 check_expr值为空，返回replace_Value ；否则 返回check_expr
- nullif （expr1, expr2）：如果两个表达式相等则返回空值，否则返回第一个表达式
- coalesce （expr1, expr2，... ）：返回第一个不为null 的expr

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.15.52@2x.png" alt="CleanShot 2024-03-30 at 19.15.52@2x" style="zoom:50%;" />

最后一个返回的是第三个表达式的值

#### 空值处理函数

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.17.04@2x.png" alt="CleanShot 2024-03-30 at 19.17.04@2x" style="zoom:50%;" />

#### 空值的排序处理

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.17.15@2x.png" alt="CleanShot 2024-03-30 at 19.17.15@2x" style="zoom:50%;" />

null是一个极小值：当指定Order by时，asc首先输出空值，desc最后输出空值

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.18.00@2x.png" alt="CleanShot 2024-03-30 at 19.18.00@2x" style="zoom:50%;" />

如果要求首先输出空值，然后由大到小输出非空值怎么办？

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.18.11@2x.png" alt="CleanShot 2024-03-30 at 19.18.11@2x" style="zoom:50%;" />

附加一个 is_null ，先按照它排序

### 连接运算

连接成分：

1. 两个输入关系
2. 连接条件：决定两个关系中哪些元组相互匹配，以及连接结果中出现哪些属性
3. 连接类型：决定如何处理与连接条件不匹配的元组

关系的连接类型:

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.46.08@2x.png" alt="CleanShot 2024-03-30 at 19.46.08@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.49.55@2x.png" alt="CleanShot 2024-03-30 at 19.49.55@2x" style="zoom:50%;" />

#### inner join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.50.47@2x.png" alt="CleanShot 2024-03-30 at 19.50.47@2x" style="zoom:50%;" />

#### left join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.50.59@2x.png" alt="CleanShot 2024-03-30 at 19.50.59@2x" style="zoom:50%;" />

#### right join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.51.11@2x.png" alt="CleanShot 2024-03-30 at 19.51.11@2x" style="zoom:50%;" />

#### left join excluding inner join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.51.28@2x.png" alt="CleanShot 2024-03-30 at 19.51.28@2x" style="zoom:50%;" />

#### full join excluding inner join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.55.58@2x.png" alt="CleanShot 2024-03-30 at 19.55.58@2x" style="zoom:50%;" />

#### cross join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.56.12@2x.png" alt="CleanShot 2024-03-30 at 19.56.12@2x" style="zoom:50%;" />

#### natural join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.56.26@2x.png" alt="CleanShot 2024-03-30 at 19.56.26@2x" style="zoom:50%;" />

#### straight join

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.56.41@2x.png" alt="CleanShot 2024-03-30 at 19.56.41@2x" style="zoom:50%;" />

强制 tbA 作为驱动表，驱动表是在循环外面的，驱动表越小越好

#### 多表连接

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.59.51@2x.png" alt="CleanShot 2024-03-30 at 19.59.51@2x" style="zoom:50%;" />

#### cross apply 与 outer apply

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.02.22@2x.png" alt="CleanShot 2024-03-30 at 20.02.22@2x" style="zoom:50%;" />

查询每位顾客购买数量排在前2位的商品

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.02.34@2x.png" alt="CleanShot 2024-03-30 at 20.02.34@2x" style="zoom:50%;" />

对customer表的每一行与buy表进行匹配

#### 不用外连接表达查询的例子

列出所有老师的教工号、姓名、工资、所教课程号

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.47.32@2x.png" alt="CleanShot 2024-03-30 at 19.47.32@2x" style="zoom:50%;" />

#### 用外连接表达查询的例子

列出所有老师的教工号、姓名、工资、所教课程号

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 19.49.39@2x.png" alt="CleanShot 2024-03-30 at 19.49.39@2x" style="zoom:50%;" />

### 集合运算

#### 集合运算的几个要点

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.06.48@2x.png" alt="CleanShot 2024-03-30 at 20.06.48@2x" style="zoom:50%;" />

要点一：集合操作缺省去除重复元组
要点二：intersect的优先级高于其他集合操作的优先级

#### 集合操作

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.07.07@2x.png" alt="CleanShot 2024-03-30 at 20.07.07@2x" style="zoom:50%;" />

#### 集合操作表达查询的例子

求工资大于1000或者年龄大于60的教工

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.07.50@2x.png" alt="CleanShot 2024-03-30 at 20.07.50@2x" style="zoom:50%;" />

问题1：等价否？不等价，union all 不去重

问题2：谁更有效？就是考虑有没有机会使用索引，union all分开写使用索引，or不使用索引

其实 union 比 union all慢多了，因为去重很慢

#### 用集合运算实现除法：选修所有课程的同学

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.12.41@2x.png" alt="CleanShot 2024-03-30 at 20.12.41@2x" style="zoom:50%;" />

### 聚集函数

将一列中所有的值聚集为单个值

平均值：avg
最小值：min
最大值：maX
总和：Sum
记数：count

#### 关于聚集函数最容易犯的语法错误

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.17.20@2x.png" alt="CleanShot 2024-03-30 at 20.17.20@2x" style="zoom:50%;" />

这个错误发生的原因是由于在SQL语句中对max()函数的使用不当造成的。

在SQL中,max()是一个聚合函数,用于从一组值中返回最大值。但是,聚合函数不能直接在WHERE子句中使用,因为WHERE子句在聚合之前进行数据过滤。

修改后的SQL语句应该是:

```sql
select sno
from SC
where grade =
	(select max( grade )
	from SC)
```

#### 聚集函数关于nul的处理： 除count（*）外忽略nul

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.22.26@2x.png" alt="CleanShot 2024-03-30 at 20.22.26@2x" style="zoom:50%;" />

#### 统计型聚集函数

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.23.26@2x.png" alt="CleanShot 2024-03-30 at 20.23.26@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.23.42@2x.png" alt="CleanShot 2024-03-30 at 20.23.42@2x" style="zoom:50%;" />

### 分组运算

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.23.54@2x.png" alt="CleanShot 2024-03-30 at 20.23.54@2x" style="zoom:50%;" />

#### 分组查询的应用场景

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.24.09@2x.png" alt="CleanShot 2024-03-30 at 20.24.09@2x" style="zoom:50%;" />

#### 分组查询的实例展示

列出每个学生的平均成绩，将SC按sno分组，再对每个分组求平均成绩

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.25.13@2x.png" alt="CleanShot 2024-03-30 at 20.25.13@2x" style="zoom:50%;" />

列出每门课程的平均成绩，将SC按cno分组，再对每个分组求平均成绩

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.25.35@2x.png" alt="CleanShot 2024-03-30 at 20.25.35@2x" style="zoom:50%;" />

#### 分组的语法形式

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.26.08@2x.png" alt="CleanShot 2024-03-30 at 20.26.08@2x" style="zoom:50%;" />

#### 分组语法正确性要点：目标列必须是分组列

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.34.42@2x.png" alt="CleanShot 2024-03-30 at 20.34.42@2x" style="zoom:50%;" />

Select 后面的必须是 group 后面的子集

#### 分组的查询示例

列出每个学生的最高、最低、平均成绩

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.36.32@2x.png" alt="CleanShot 2024-03-30 at 20.36.32@2x" style="zoom:50%;" />

#### 比较两个外观类似的查询

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.38.42@2x.png" alt="CleanShot 2024-03-30 at 20.38.42@2x" style="zoom:50%;" />

列出每一年龄组中男学生（超过50人）的人数

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.38.52@2x.png" alt="CleanShot 2024-03-30 at 20.38.52@2x" style="zoom:50%;" />

执行顺序：

Where -> group by -> having

#### LeetCode1748：求唯一元素之和

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.40.24@2x.png" alt="CleanShot 2024-03-30 at 20.40.24@2x" style="zoom:50%;" />

#### group_concat：串接字称串

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.40.43@2x.png" alt="CleanShot 2024-03-30 at 20.40.43@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.41.57@2x.png" alt="CleanShot 2024-03-30 at 20.41.57@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.42.07@2x.png" alt="CleanShot 2024-03-30 at 20.42.07@2x" style="zoom:50%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.42.19@2x.png" alt="CleanShot 2024-03-30 at 20.42.19@2x" style="zoom:50%;" />

### 从 group by 到 cube

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.43.08@2x.png" alt="CleanShot 2024-03-30 at 20.43.08@2x" style="zoom:50%;" />

#### 所有可能的分析需求

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.43.30@2x.png" alt="CleanShot 2024-03-30 at 20.43.30@2x" style="zoom:50%;" />

使用cube

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.44.34@2x.png" alt="CleanShot 2024-03-30 at 20.44.34@2x" style="zoom:50%;" />

#### cube的使用语法

<img src="./4.SQL.assets/CleanShot 2024-03-30 at 20.44.54@2x.png" alt="CleanShot 2024-03-30 at 20.44.54@2x" style="zoom:50%;" />

总行数：每一个列在cube之后都可以取n+1种值，+1是因为多了一个 ALL 值
