# 第四章 SQL

## SQL简介

### SQL的起源

SQL: Struceured Query Languang
1974年，由Boyce和Chamber提出，称为Sequel
1975-1979年，在System R上实现，由IBM San Jose研究室研制

### SQL语言的特点

语言简洁，易学易用

面向集合的操作方式：一次一集合

高度非过程化：用户只需提出“做什么”，无须告诉“怎么做”，不必了解存取路径

一体化
集DDL，DML，DCL于一体，单一的结构——关系，带来了数据操作符的统一

两种使用方式，统一的语法结构：既是自含式（用户使用）的，又是嵌入式的（程序员使用）

### SQL的标准化

### SQL主要操作符

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.16.23@2x.png" alt="CleanShot 2024-03-19 at 16.16.23@2x" style="zoom:30%;" />

### SQL：数据访问的事实标准

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.16.43@2x.png" alt="CleanShot 2024-03-19 at 16.16.43@2x" style="zoom:30%;" />

### 约定俗成：提供一个类SQL接口

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.17.07@2x.png" alt="CleanShot 2024-03-19 at 16.17.07@2x" style="zoom:30%;" />

## SQL数据模式定义

### 标准SQL中的数据定义对象

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.19.59@2x.png" alt="CleanShot 2024-03-19 at 16.19.59@2x" style="zoom:30%;" />

### 实际数据库中的定义对象： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.20.13@2x.png" alt="CleanShot 2024-03-19 at 16.20.13@2x" style="zoom:30%;" />

### 术语讨论：模式

MySQL：模式即是数据库

SQL Server：模式把对家和用户分离开来

对象命名：〈数据库〉.〈模式〉.〈表〉

创建模式
create schema < 模式名＞
create schema University.Library

### 数据库定义： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.24.29@2x.png" alt="CleanShot 2024-03-19 at 16.24.29@2x" style="zoom:30%;" />

最简单的创建数据库的命令：create database University
use 命令指定当前要使用的数据库：use University

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.24.55@2x.png" alt="CleanShot 2024-03-19 at 16.24.55@2x" style="zoom:30%;" />

create database ＜ 数据库名＞
[ default character set utf8
default collate utf8_Chinese_ci ]

create database 等同于 create schema

### MySQL表空间

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.27.20@2x.png" alt="CleanShot 2024-03-19 at 16.27.20@2x" style="zoom:30%;" />

### 创建基本表的语法命令

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.27.35@2x.png" alt="CleanShot 2024-03-19 at 16.27.35@2x" style="zoom:40%;" />

#### 创建表示例

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.28.00@2x.png" alt="CleanShot 2024-03-19 at 16.28.00@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.28.10@2x.png" alt="CleanShot 2024-03-19 at 16.28.10@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.28.24@2x.png" alt="CleanShot 2024-03-19 at 16.28.24@2x" style="zoom:40%;" />

### 修改基本表

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.29.06@2x.png" alt="CleanShot 2024-03-19 at 16.29.06@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.29.40@2x.png" alt="CleanShot 2024-03-19 at 16.29.40@2x" style="zoom:40%;" />

### 删除基本表

drop table 表名

drop table不能删除被foreign key约束所引用的表，必须先除去foreign key约束或引用表

任何引用已删除表的视图或存储过程必须通过drop view或drop procedure语句显式除去

DANGER：刪除表定义及该表的所有数据、索引、触发器、约束和权限规范

### 表定义相关的字典表： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.33.29@2x.png" alt="CleanShot 2024-03-19 at 16.33.29@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.33.44@2x.png" alt="CleanShot 2024-03-19 at 16.33.44@2x" style="zoom:40%;" />

### 标准SQL中的信息视图

INFORMATION_ SCHEMA.SCHEMATA
INFORMATION SCHEMA. TABLES
INFORMATION_SCHEMA.COLUMNS
INFORMATION_SCHEMA.CHECK_CONSTRAINTS
INFORMATION_SCHEMA.VIEWS
INFORMATION_SCHEMA.DOMAINS

### MySQL中的信息视图查询

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.34.19@2x.png" alt="CleanShot 2024-03-19 at 16.34.19@2x" style="zoom:30%;" />

### SQL数据定义特点

SQL中，任何时候都可以执行一个数据定义语包，随时修改数据库结构

- 数据库定义不断增长（不必一开始就定义完整）
- 数据库定义随时修改（不必一开始就完全合理）
- 可进行增加索引、撤消索引的实验，检验其效率影响



- 在非关系型数据库系统中，必须在数据库使用前全部完成数据库定义
- 若要修改已投入运行的数据库，则需停下一切数据库活动，卸出数据库，修改数据库定义并重新编译，再按修改后的数据库结构重新装入数据

思考：MySQL是如何实现alter table的？新建一个表，drop旧表

## SQL数据类型定义

### 数据类型全家福

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.35.48@2x.png" alt="CleanShot 2024-03-19 at 16.35.48@2x" style="zoom:30%;" />

### 整型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.36.48@2x.png" alt="CleanShot 2024-03-19 at 16.36.48@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.37.46@2x.png" alt="CleanShot 2024-03-19 at 16.37.46@2x" style="zoom:40%;" />

溢出：

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.44.04@2x.png" alt="CleanShot 2024-03-19 at 16.44.04@2x" style="zoom:40%;" />

宽松模式、严格模式：

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.44.37@2x.png" alt="CleanShot 2024-03-19 at 16.44.37@2x" style="zoom:30%;" />

### 定点数与浮点数

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.44.54@2x.png" alt="CleanShot 2024-03-19 at 16.44.54@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.04@2x.png" alt="CleanShot 2024-03-19 at 16.45.04@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.14@2x.png" alt="CleanShot 2024-03-19 at 16.45.14@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.23@2x.png" alt="CleanShot 2024-03-19 at 16.45.23@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.32@2x.png" alt="CleanShot 2024-03-19 at 16.45.32@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.43@2x.png" alt="CleanShot 2024-03-19 at 16.45.43@2x" style="zoom:30%;" />

### money数据类型

money使用4位小数存储数据，容易发生小数的舍入错误

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.45.57@2x.png" alt="CleanShot 2024-03-19 at 16.45.57@2x" style="zoom:30%;" />

### 如何给女朋友解释为什么计算机中0.2+ 0.2 +0.1 不等于 0.3 ？

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.46.35@2x.png" alt="CleanShot 2024-03-19 at 16.46.35@2x" style="zoom:30%;" />

### 字符型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.46.49@2x.png" alt="CleanShot 2024-03-19 at 16.46.49@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.46.59@2x.png" alt="CleanShot 2024-03-19 at 16.46.59@2x" style="zoom:30%;" />

#### 定义者的选择： char or varchar ?

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.47.27@2x.png" alt="CleanShot 2024-03-19 at 16.47.27@2x" style="zoom:30%;" />

变长之利：减少存储开销 ＋ 元组数/页 高

变长之弊：查询计算偏移 ＋ 更新挪移数据

变长之用：长短显著不一+ 很少发生变化

### 字符集

字符集（character set）：字符＋编码

字符序（collation）：字符比较规则
•宇符按其编码比较大小
•如果两个字符为大小写关系，则它们相等

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.48.41@2x.png" alt="CleanShot 2024-03-19 at 16.48.41@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.49.11@2x.png" alt="CleanShot 2024-03-19 at 16.49.11@2x" style="zoom:30%;" />

### 日期型数据类型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.51.27@2x.png" alt="CleanShot 2024-03-19 at 16.51.27@2x" style="zoom:30%;" />

使用：

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.03@2x.png" alt="CleanShot 2024-03-19 at 16.55.03@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.16@2x.png" alt="CleanShot 2024-03-19 at 16.55.16@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.29@2x.png" alt="CleanShot 2024-03-19 at 16.55.29@2x" style="zoom:30%;" />

UNIX时间戳

### 日期类型：SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.55.46@2x.png" alt="CleanShot 2024-03-19 at 16.55.46@2x" style="zoom:30%;" />

格里高利改历法

### 枚举型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.56.32@2x.png" alt="CleanShot 2024-03-19 at 16.56.32@2x" style="zoom:30%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.56.41@2x.png" alt="CleanShot 2024-03-19 at 16.56.41@2x" style="zoom:30%;" />

### 二进制类型

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.56.54@2x.png" alt="CleanShot 2024-03-19 at 16.56.54@2x" style="zoom:30%;" />

### 显式数据类型转换

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.57.29@2x.png" alt="CleanShot 2024-03-19 at 16.57.29@2x" style="zoom:30%;" />

### 隐式数据类型转换

如果不指定显式类型转换，那么在对两个不同数据类型的列值进行运算时，系统会进行隐式类型转换，也即先将它们转换为同一个数据类型，然后再进行运算

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.57.47@2x.png" alt="CleanShot 2024-03-19 at 16.57.47@2x" style="zoom:30%;" />

### 用户定义数据类型 UDDT:User-defined datatype

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.58.01@2x.png" alt="CleanShot 2024-03-19 at 16.58.01@2x" style="zoom:30%;" />

### 用户定义数据类型： SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-19 at 16.58.16@2x.png" alt="CleanShot 2024-03-19 at 16.58.16@2x" style="zoom:30%;" />

### 特殊类型

XML
JSON
空间数据
数据类型决定了数据库适用范围，如果数据库不支持日期类型会怎样？

### Oracle中如何表示复杂实体？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.35.18@2x.png" alt="CleanShot 2024-03-24 at 14.35.18@2x" style="zoom:30%;" />

### rowversion 数据类型

如果表中有一列被声明为rowversion，只要行被修改，其rowversion列就会发生改变。它是跨表唯一的，任何表的修改都会使该值递增

可以检测出一行记录是否被别人修改过

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.37.25@2x.png" alt="CleanShot 2024-03-24 at 14.37.25@2x" style="zoom:40%;" />

### uniqueidentifier 数据类型

uniqueidentifier() 产生跨数据库和服务器的全局唯一标识符（GUID）
newid() 函数产生uniqueidentifier 类型的值
newsequentialid() 产生的GUID总是大于先前通过该函数生成的GUID

select newid0）的输出结果如下：DD64B592-D477-4114-8131-32E9FCB540FA

#### 冗长主码的危害

如果使用UUID作为主码

保证其惟一性必须进行字符匹配

一个表的主码经常是另外一个表的外码，而外码是对主码的复制，冗长的主码加上外码会占据很大的表空间

表连接一般是基于主外码的，为加快查询会在主外码上建立索引，冗长主码会使得一个页面里容纳很少的索引项，从而增加查找数据时的磁盘IO 数

### MySQL中的自增字段

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.39.42@2x.png" alt="CleanShot 2024-03-24 at 14.39.42@2x" style="zoom:40%;" />

自增不保证唯一，不一定是主码

### SQL Server中的序列号：identity

identity [(seed, increment)]

为没有有效主码的表提供计数器，有一个起始数（种子），增量值（步长）

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.42.30@2x.png" alt="CleanShot 2024-03-24 at 14.42.30@2x" style="zoom:50%;" />

### SQL Server中的序列号：sequence

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.42.46@2x.png" alt="CleanShot 2024-03-24 at 14.42.46@2x" style="zoom:30%;" />

## SQL视图和临时表定义

### 视图

视图是命名的、以基本表中导出的虚表，它在物理上并不存在，存在的只是其定义，属于外模式

视图中的数据是以基本表中导出的，每次对视图查询都要重新计算

视图之上可以再定义视图

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.43.20@2x.png" alt="CleanShot 2024-03-24 at 14.43.20@2x" style="zoom:50%;" />

### 视图的SQL定义

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.43.55@2x.png" alt="CleanShot 2024-03-24 at 14.43.55@2x" style="zoom:50%;" />

视图的属性名缺省为子查询结果中的属性名，也可以显式指明

with check option指明当对视图进行insert，update时，要检查是否满足视图定义中的条件

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.44.07@2x.png" alt="CleanShot 2024-03-24 at 14.44.07@2x" style="zoom:50%;" />

#### 视图定义的示例

定义一个包含计算机系教工基本信息的视图

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.44.35@2x.png" alt="CleanShot 2024-03-24 at 14.44.35@2x" style="zoom:40%;" />

### 基于视图的查询

给出计算机系工资超过1000的教工姓名

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.45.04@2x.png" alt="CleanShot 2024-03-24 at 14.45.04@2x" style="zoom:40%;" />

### 视图定义中的with check option选项

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.45.20@2x.png" alt="CleanShot 2024-03-24 at 14.45.20@2x" style="zoom:40%;" />

如果有 with check option, 那么下面这个就插入不进去

### 视图的优点

个性化服务：简化用户观点，使不同用户可以以不同角度现察同一数据

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.45.44@2x.png" alt="CleanShot 2024-03-24 at 14.45.44@2x" style="zoom:40%;" />

逻辑独立性：视图作为基本表与外模式之间的映象

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.54.16@2x.png" alt="CleanShot 2024-03-24 at 14.54.16@2x" style="zoom:40%;" />

安全性：“知必所需”，限制用户数据的访问范围

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.54.33@2x.png" alt="CleanShot 2024-03-24 at 14.54.33@2x" style="zoom:40%;" />

### 不可更新的视图示例

视图定义中不包括基表主码

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.55.18@2x.png" alt="CleanShot 2024-03-24 at 14.55.18@2x" style="zoom:40%;" />

视图定义中包含聚集函数

对聚集值的更新无法回逆到基表的行上面：

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.56.11@2x.png" alt="CleanShot 2024-03-24 at 14.56.11@2x" style="zoom:40%;" />

视图定义中没有包括连接属性

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 14.56.44@2x.png" alt="CleanShot 2024-03-24 at 14.56.44@2x" style="zoom:40%;" />

为什么不允许更新不包括连接属性的视图？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.00.54@2x.png" alt="CleanShot 2024-03-24 at 15.00.54@2x" style="zoom:40%;" />

### 视图更新约束

不可更新视图：
select子句中的目标列包含了聚集函数
select子句中使用unique或distinct关键字
select于句中包含经算术表达式计算出来的列
from子句中包含了多个表
包含了group by子句

对于行列子集视图可以更新（视图是以单个基本表使用选择、投影操作导出的，并且包含了基本表的主码）

### 全关系系統准则6：视图更新准则

所有理论上可更新的视图也应该由系统更新，即对视图的更新要求，存在一个算法可以无二义地把更新要求转换为对基本表的更新序列

#### 什么是理论上可更新的视田？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.05.30@2x.png" alt="CleanShot 2024-03-24 at 15.05.30@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.05.45@2x.png" alt="CleanShot 2024-03-24 at 15.05.45@2x" style="zoom:40%;" />

其中中间这个是理论上可更新的，数据库如果不能分辨出它是可以更新的，那么数据库存在问题

### 临时表和内存表

如果语句很复杂，连接太多，可以用临时表分步完成

如果多次用到一个大表的同一部分数据，可以用临时表暂存这部分数据

如果需要综合多个表的数据，形成一个结果，可以考虑用临时表分步汇总这多个表的数据

频繁使用的表可以放在内存中

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.06.17@2x.png" alt="CleanShot 2024-03-24 at 15.06.17@2x" style="zoom:40%;" />

#### 临时表和内存表的对比

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.08.17@2x.png" alt="CleanShot 2024-03-24 at 15.08.17@2x" style="zoom:40%;" />

#### 查询中的临时表

允许在from子旬中使用子查询表达式，这时可将该子查询的结果命名为一个临时表加以引用

（子查询） as 关系名（列名，列名，⋯）

#### 查询中的临时表示例

找出平均成绩及格的学生（不用having子句）

先求每个学生的平均成绩，再从中找出及格的学生

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.09.51@2x.png" alt="CleanShot 2024-03-24 at 15.09.51@2x" style="zoom:50%;" />

### 公用表表达式CTE

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.10.22@2x.png" alt="CleanShot 2024-03-24 at 15.10.22@2x" style="zoom:40%;" />

### values （表值构造器） FOW（行值构造器）

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.12.12@2x.png" alt="CleanShot 2024-03-24 at 15.12.12@2x" style="zoom:40%;" />

## 分区表定义

### 数据分区

把逻辑上统一的数据分割成较小的、可以独立管理的物理单元（分片）进行存储

可接时间、按地区、按业务类型进行数据分割

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.14.38@2x.png" alt="CleanShot 2024-03-24 at 15.14.38@2x" style="zoom:40%;" />

### 数据分区的优点

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.14.53@2x.png" alt="CleanShot 2024-03-24 at 15.14.53@2x" style="zoom:40%;" />

### 一般的分区方式

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.15.12@2x.png" alt="CleanShot 2024-03-24 at 15.15.12@2x" style="zoom:40%;" />

### MySQL支持的表分区类型

create table tb _name.........)
partition by ...

1. range分区

2. list分区
3. columns分区
4. hash分区
5. key分区
6. 子分区

#### MySQL的range分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.16.22@2x.png" alt="CleanShot 2024-03-24 at 15.16.22@2x" style="zoom:40%;" />

#### MySQL的list分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.16.57@2x.png" alt="CleanShot 2024-03-24 at 15.16.57@2x" style="zoom:40%;" />

#### MySQL的常规hash分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.17.16@2x.png" alt="CleanShot 2024-03-24 at 15.17.16@2x" style="zoom:40%;" />

取模运算。假设分区数为4，则有0，1，2，3四个值，对应分区为四个

83模4取余得3，将数据放在第三个分区中

#### MySQL的线性hash分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.17.51@2x.png" alt="CleanShot 2024-03-24 at 15.17.51@2x" style="zoom:50%;" />

1. 计算V=power （2, ceiling（1og（2， 分区数））），假设分区数为4，V=4

2. 对分区键和V-1进行位与运算

假设分区键值为8（10），8（10）与3进行按位与运算得出插入分区是0（2）

#### MySQL的range columns分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.18.49@2x.png" alt="CleanShot 2024-03-24 at 15.18.49@2x" style="zoom:40%;" />

#### MySQL的list columns分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.19.11@2x.png" alt="CleanShot 2024-03-24 at 15.19.11@2x" style="zoom:40%;" />

#### MySQL的key分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.19.25@2x.png" alt="CleanShot 2024-03-24 at 15.19.25@2x" style="zoom:40%;" />

#### MySQL的子分区

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.19.40@2x.png" alt="CleanShot 2024-03-24 at 15.19.40@2x" style="zoom:40%;" />

### 分区表：SQL Server

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.20.08@2x.png" alt="CleanShot 2024-03-24 at 15.20.08@2x" style="zoom:40%;" />

## SQL索引定义

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.20.48@2x.png" alt="CleanShot 2024-03-24 at 15.20.48@2x" style="zoom:40%;" />

### 为什么需要索引？

关系表是个无序集合

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.21.14@2x.png" alt="CleanShot 2024-03-24 at 15.21.14@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.21.31@2x.png" alt="CleanShot 2024-03-24 at 15.21.31@2x" style="zoom:40%;" />

### 索引的直观解释

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.21.47@2x.png" alt="CleanShot 2024-03-24 at 15.21.47@2x" style="zoom:40%;" />

### 索引在数据库系统内部的存储结构

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.22.25@2x.png" alt="CleanShot 2024-03-24 at 15.22.25@2x" style="zoom:40%;" />

### 索引在数据库内部的作用

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.22.45@2x.png" alt="CleanShot 2024-03-24 at 15.22.45@2x" style="zoom:40%;" />

### 索引的创建

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.23.06@2x.png" alt="CleanShot 2024-03-24 at 15.23.06@2x" style="zoom:40%;" />

### 索引的删除

drop index 索引名

drop index 语句不适用于通过定义，primary key 或 unique约束创建的索引，它们必须通过除去约束来撤销

### 索引的排序

asC/desC：索引表中索引值的排序次序，缺省为asc

为什么需要降序索引？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.24.33@2x.png" alt="CleanShot 2024-03-24 at 15.24.33@2x" style="zoom:40%;" />

### unique：唯一性索引

不允许表中不同的行在索引列上取相同值

若已有相同值存在，则系统给出相关信息，不建此索引

系统拒绝违背唯一性的插入、更新

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.25.22@2x.png" alt="CleanShot 2024-03-24 at 15.25.22@2x" style="zoom:40%;" />

### 创建索引选项：InnoDB_fill_factor

fill_factor指定在创建索引的过程中，各索引页的填满程度

为何索引页要预留空间？如果某个索引页填满，系统就必须花时间拆分该索引页，以便为新行腾出空间，这需要很大开销并造成索引碎片

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.27.52@2x.png" alt="CleanShot 2024-03-24 at 15.27.52@2x" style="zoom:40%;" />

### 索引碎片

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.28.11@2x.png" alt="CleanShot 2024-03-24 at 15.28.11@2x" style="zoom:50%;" />

索引碎片：页面逻辑顺序与物理顺序不一致

Q1：索引碎片的负面影响？ 效率低

Q2：如何消除索引碎片？重建索引

### 聚簇索引

cluster：聚簇索引
表中元组按索引项的值排序并物理地聚簇在一起
一个基本表上只能建一个聚簇索引

聚簇索引使得逻辑访问顺序和物理存储顺序尽可能一致

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.28.50@2x.png" alt="CleanShot 2024-03-24 at 15.28.50@2x" style="zoom:40%;" />

### 组合索引

组合索引：建立在多个属性列上的索引

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.29.21@2x.png" alt="CleanShot 2024-03-24 at 15.29.21@2x" style="zoom:40%;" />

#### 组合索引的用场

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.29.34@2x.png" alt="CleanShot 2024-03-24 at 15.29.34@2x" style="zoom:40%;" />

索引不一定总是快。

因为索引总是使用随机读，随机读远远慢于顺序读。

并且顺序读的速度一直在提高，随机读的速度不怎么提高，这就导致之前如果使用索引最多允许20%随机读，否则就比不用索引满了，最近只允许2%。

那么为什么索引会导致随机读呢？我要在索引中查找，然后再前往原表。所以如果要避免随机读，就要把数据一开始就放在索引中。

##### 下面哪个组合索引效果会更好？

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.29.54@2x.png" alt="CleanShot 2024-03-24 at 15.29.54@2x" style="zoom:40%;" />

### 覆盖索引

把select中的列也包含进索引中，这样就可以完全基于索引回答查询，避免对表的访问

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.30.20@2x.png" alt="CleanShot 2024-03-24 at 15.30.20@2x" style="zoom:50%;" />

与组合索引的差别：B值不出现在索引的中间结点上

### 过滤索引

在索引的定义中加入Where语句，索引中只包括那些满足过滤条件的列值

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.30.51@2x.png" alt="CleanShot 2024-03-24 at 15.30.51@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.31.04@2x.png" alt="CleanShot 2024-03-24 at 15.31.04@2x" style="zoom:40%;" />

### 函数索引

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.31.29@2x.png" alt="CleanShot 2024-03-24 at 15.31.29@2x" style="zoom:40%;" />

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.31.41@2x.png" alt="CleanShot 2024-03-24 at 15.31.41@2x" style="zoom:40%;" />

### 索引的使用说明

一个表上可建多个索引

可以动态地定义索引
随时建立和删除索引

索引可以提高查询效率
耗费空间
降低插入、删除、更新效率

•理想化状态：不允许用户在数据操作中引用索引
• 数据的物理独立性：索引如何使用完全由系统决定

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.32.27@2x.png" alt="CleanShot 2024-03-24 at 15.32.27@2x" style="zoom:50%;" />

### 索引的选择度：建否？

索引的理想选择度=1/索引列的唯一值个数(集势Cardinality (NUM_DISTINCT))

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.33.35@2x.png" alt="CleanShot 2024-03-24 at 15.33.35@2x" style="zoom:50%;" />

A列的索引选择度为0.25 B列的索引选择度为0.5

So Easy：应该在哪些列上建索引？A，哈希冲突少

### 索引的选择度：用否？

索引的实际选择度=查询结果行数/总行数 NUM_ROWS

“=”的索引选择度为1/ NUM_DISTINCT
“<>”的索引选择度是多少？
“>=”的索引选择度是多少？
在分布不均匀的情况，如何估计选择度的大小？

什么时候用索引？什么时候表扫描？满足条件的记录少于整体的2%才启用索引

### 索引的选择（2024-3-22）

<img src="./4.SQL.assets/CleanShot 2024-03-24 at 15.34.21@2x.png" alt="CleanShot 2024-03-24 at 15.34.21@2x" style="zoom:40%;" />
