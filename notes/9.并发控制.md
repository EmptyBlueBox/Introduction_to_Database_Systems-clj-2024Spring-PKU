# 第九章 并发控制

## 两段锁协议

### 封锁的定义

一个事务对某个数据对象加锁 ， 取得对它一定的控制，限制其它事务对该数据对象使用

要访问数据项 𝑅 , 事务𝑇 𝑖 必须先申请对 𝑅 的封锁，如果𝑅 已经被 事务𝑇 𝑗 加了不相容的锁，则𝑇 𝑖 需要等待，直至𝑇 𝑗 释放它的封锁

长锁：保持到事务结束时才释放

短锁：在事务中途就可以释放的锁

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 11.01.48@2x.png" alt="CleanShot 2024-05-25 at 11.01.48@2x" style="zoom:50%;" />

### 两阶段封锁协议

增长阶段(Growing Phase): 事务可以获得锁，但不能释放锁

缩减阶段(Shrinking Phase): 事务可以释放锁，但不能获得锁

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 11.05.17@2x.png" alt="CleanShot 2024-05-25 at 11.05.17@2x" style="zoom:50%;" />

问题：哪个事务隔离性级别不满足2PL？

Read uncommit 和 Read commit 都不满足

### 两阶段封锁协议的作用

保证可串行化

若一组事务均服从两阶段封锁协议，则它们的调度一定是可串行化的

#### 问题：如何确定等价的串行顺序？

封锁点：事务获得最后封锁的时间

事务调度等价于和其封锁点顺序一致的串行调度

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 11.13.53@2x.png" alt="CleanShot 2024-05-25 at 11.13.53@2x" style="zoom:50%;" />

问题：t1, t2, t3满足2PL则等价的串行顺序是？ 132

### 为什么两阶段封锁协议保证可串行化？

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 11.14.44@2x.png" alt="CleanShot 2024-05-25 at 11.14.44@2x" style="zoom:50%;" />

## 封锁类型

### 基本锁类型

#### 排它锁（X锁，eXclusive lock）

lock-X(R) ：又称写锁 ， 持有 X 锁

可以读写数据项 事务 T 对数据对象 R 加上 X 锁 ， 则 其它事务对 R 的任何封锁请求都 不能成功，直至T释放R上的X锁

#### 共享锁（S锁，Share lock）

lock-S(R)：又称读锁，持有S锁

只能读取数据项 事务T对数据对象R加上S锁，则 其它事务对 R 的 X 锁请求不能成功，而对R的S锁请求可以成功

### 相容矩阵

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 11.24.54@2x.png" alt="CleanShot 2024-05-25 at 11.24.54@2x" style="zoom:50%;" />

并发度很低

### 先读后写场合中的锁转换

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 11.30.57@2x.png" alt="CleanShot 2024-05-25 at 11.30.57@2x" style="zoom:50%;" />

并发度太低了, 两种更好的并发策略:

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 11.31.11@2x.png" alt="CleanShot 2024-05-25 at 11.31.11@2x" style="zoom:50%;" />

### 带有锁转换的两段锁协议

增长阶段

1. 可获得lock-S和lock-X 
2. 可将lock-S升级为lock-X (upgrade)

缩减阶段

1. 可释放lock-S和lock-X 
2. 可将lock-X降级为lock-S (downgrade)

#### 升级锁和重新申请锁有区别吗？

排队顺序不同

升级锁已经在队列中, 可以更快获得批准; 重新申请锁需要从头排队, 获取锁更慢

#### 在哪个隔离性级别下会出现锁转换？

repeated committed

Read commit 不出现锁转换, 因为锁转换要求一直持有读锁, 没有释放

#### 锁转换带来的问题

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 11.36.10@2x.png" alt="CleanShot 2024-05-25 at 11.36.10@2x" style="zoom:50%;" />

如果都使用升级锁:

T1要升级锁的时候, 会被T2的读锁阻止

T2要升级锁的时候, 会被T1的读锁阻止

这是一个死锁

#### 避免死锁

使用更新锁

更新锁（U锁，Update lock）: 当一个事务查询数据以便将来要进行修改时，可以对数据项施加更新锁

如果事务修改资源, 需将更新锁转换为排它锁, 一次只有一个事务可以获得资源上的更新锁

S和U锁相容吗? 相容, S不能被升级, 纯读, 一直可以相容

持有U锁可以对数据执行什么操作？将来可以升级

更新锁的相容性:

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 11.40.50@2x.png" alt="CleanShot 2024-05-25 at 11.40.50@2x" style="zoom:50%;" />

注意S<U<X, 锁的级别越来越高, 直到完全不相容

### 封锁粒度

封锁对象：属性值、元 关系、数据库、索引项、 索引、物理页、块

封锁粒度大，则并发度低，开销小; 封锁粒度小，则并发度高，开销高

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 12.01.00@2x.png" alt="CleanShot 2024-05-25 at 12.01.00@2x" style="zoom:50%;" />

访问小部分数据, 使用粒度小的锁; 访问大部分数据, 使用粒度大的锁

系统必须支持多粒度锁, 根据查询范围选择最佳粒度

#### 多粒度封锁中的隐含冲突

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 12.01.48@2x.png" alt="CleanShot 2024-05-25 at 12.01.48@2x" style="zoom:50%;" />

如何检测冲突？直接封锁无法防范包含对象之间的潜在冲突

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 12.04.41@2x.png" alt="CleanShot 2024-05-25 at 12.04.41@2x" style="zoom:50%;" />

意向锁：告示条

症结：在分层封锁中，封锁了上层节点就意味着封锁了所有内层节 点。如果有事务T1对某元组加了S锁，而事务T2对该元组所在的关 系加了X锁，因而隐含地X封锁了该元组，从而造成矛盾 

措施：引入意向锁I（Intend）。当为某节点加上I锁，表明其某些 内层节点已发生事实上的封锁，防止其它事务再去显式封锁该节点

过程：I锁的实施是从封锁层次的根开始 ，依次占据路径上的所有 节点，直至要真正进行显式封锁的节点的父节点为止

就是从root开始到叶子结点路径上除了叶子结点都是意向锁

#### 意向锁I的相容性

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 12.06.56@2x.png" alt="CleanShot 2024-05-25 at 12.06.56@2x" style="zoom:50%;" />

为什么I锁**之间**是相容的？在非叶子结点上的I锁是可以相容的

#### 意向锁I的不足之处

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 12.08.28@2x.png" alt="CleanShot 2024-05-25 at 12.08.28@2x" style="zoom:50%;" />

第一个冲突是对的, 第二个按理来说不应该冲突, 因为内部是S锁, 不应该和另一个S互斥

I锁告白不明，没有揭示内层锁的类型

#### 更为精细化的意向锁

IS锁：对一个数据对象加IS锁，表示它的 后裔节点拟（意向）加S锁

IX锁：对一个数据对象加IX锁，表示它的 后裔节点拟（意向）加X锁

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 12.10.39@2x.png" alt="CleanShot 2024-05-25 at 12.10.39@2x" style="zoom:50%;" />

### 共享与意向排他锁SIX

SIX = S + IX

在表上对表加SIX锁，则表示该事务要读整个表（S锁），同时会更新个别元组（IX锁）

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 12.12.58@2x.png" alt="CleanShot 2024-05-25 at 12.12.58@2x" style="zoom:50%;" />

### 码范围锁

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 12.17.25@2x.png" alt="CleanShot 2024-05-25 at 12.17.25@2x" style="zoom:50%;" />

索引是有序的

码范围锁定原理解决了幻像并发问题

码范围锁通过覆盖索引行和索引行之间的范围来工作，因为第二个事务在 该范围内进行任何行插入、更新或删除操作时均需要修改索引，而码范围 锁覆盖了索引项，所以在第一个事务完成之前会阻塞第二个事务的进行

召唤神龙，码范围锁出现的条件: 索引 + serializable

#### 码范围锁模式兼容性矩阵

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 13.20.31@2x.png" alt="CleanShot 2024-05-25 at 13.20.31@2x" style="zoom:50%;" />

RangeS_S: 第一个S代表对这个范围上锁S, 第二个S代表对索引码上锁S   

一个读取的事务上锁 RangeS_S, 另一个插入的事务上锁 RangeI_N

#### 查询示例

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 13.30.57@2x.png" alt="CleanShot 2024-05-25 at 13.30.57@2x" style="zoom:50%;" />

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 13.30.29@2x.png" alt="CleanShot 2024-05-25 at 13.30.29@2x" style="zoom:50%;" />

Dallas, Donovan和Duluth是叶级顺序索引码，前两个码将获得码范围锁RangeS_S

码范围锁防止任何向以这两个码结束的区间插入数据 。没有大于Dallas且小于等于 Donovan的行可以插入，也没有大于Donovan且小于等于Duluth的行可以插入

#### 其他事务能插入'Dashagua' 吗? 

看起来不在查询范围之内, 但是实际上也不能插入. 因为实际封锁的区域是按照表中实际存在的表项来看的, Delaney 不在表中, 所以上界会变大, 变成了 Dallas, 这样的话Dashagua就不能插入了

### 闩锁

lock：保护逻辑对象

latch：保护内存页

如果不对内存页加锁保护会如何？页头会被写错误

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 13.37.53@2x.png" alt="CleanShot 2024-05-25 at 13.37.53@2x" style="zoom:50%;" />

为什么不用通常的排宅锁实现？代价太高，延迟太大

闩锁类似于多线程编程里的临界区（Critcal Section）自旋锁 spinlock

查看互斥锁：show engine innodb mutex

使用序列号做聚簇索引码的问题：多个进程往同一页密集写入数据

## 封锁问题

### 阻塞

缺少索引而引起的阻塞

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 13.42.21@2x.png" alt="CleanShot 2024-05-25 at 13.42.21@2x" style="zoom:50%;" />

1. 连接1在表上没有找到索引, 因此进行全表探查, 全部加U锁
2. 找到101表项, 讲其升级为X锁, 释放其余所有U锁
3. 连接2在表上没有找到索引, 因此进行全表探查, 全部加U锁
4. 在试图对101表项加U锁的时候与X锁冲突
5. 出现阻塞问题
6. 因此需要创建索引, 就不用对所有表项加U锁了

根据这个例子, 因此建立索引有助于提高并发性

### 死锁

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 13.45.31@2x.png" alt="CleanShot 2024-05-25 at 13.45.31@2x" style="zoom:50%;" />

两个事务都封锁了一些数据对象, 并相互等待对方释放另一些数据对象以便对其封锁, 结果两个事务都不能结束，则发生死锁

① 互斥条件：事务请求对资源的独占控制 

② 占有等待条件：事务已持有一定资源，又去申请并等待其它资源 

③ 非抢占条件：直到资源被持有它的事务释放之前，不能将该资源强制从持有它的事务夺去 

④ 循环等待条件：存在事务相互等待的等待圈

定理：在条件① ② ③成立的前提下，条件④ 是死锁存在的充分必要条件

#### 死锁示例

<img src="./9.并发控制.assets/CleanShot 2024-05-25 at 13.47.53@2x.png" alt="CleanShot 2024-05-25 at 13.47.53@2x" style="zoom:50%;" />

根据资源在谁那里画有向图, 如果有环就说明有死锁

### 活锁

## 其他锁概念